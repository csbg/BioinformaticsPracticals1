[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bioinformatics Practicals I",
    "section": "",
    "text": "Modern Life Sciences rely on various computer programs to analyze large biological datasets. The next generation of biologists thus requires basic expertise with high-performance computing, software tools, and automated application of analyses.\nIn this practical, you will learn to interact with operating systems through commands in an HPC environment as well as basics of programming in a scripting language."
  },
  {
    "objectID": "python3.html",
    "href": "python3.html",
    "title": "Python Unit 3",
    "section": "",
    "text": "Python supports, amongst others, the object-oriented programming paradigm. While hundreds of books have been written on this paradigm, it is actually quite easy to grasp: Think of a program as a collection of objects that communicate with each other. Each object has\n\nattributes describing its state, and\nmethods that allow to change these attributes.\n\nBefore we can create an object, we first have to define a “blueprint” (class) for a certain type of object. Then, we may create one or more objects from this class via a process known as instantiation. Each of these objects will have the same set of attributes and methods, but the attributes will typically differ in their values.\nSince all those concepts may sound quite abstract at first, here’s a comprehensive example. We will create a class that represents proteins. Our implementation remains simple, but you will have the opportunity to add functionality in the exercises.\nAll statements of this section (i.e., the class definitions) should be stored in simple_protein.py.\n\n\nA protein is characterized by its name and amino acid sequence. Hence, the protein class needs at least two attributes:\nclass Protein:\n    def __init__(self, name, sequence):\n        self.name = name\n        self.sequence = sequence\nThe code above defines a new class:\n\nkeyword class\nclass name (here Protein)\ncolon\nindented statements (suite, class body)\n\nWe also define an init method, which must be named __init__() and is called by Python whenever a new object is instantiated from the class. In the body of the init method, we initialize the instance variables self.name and self.sequence. These variables store the name and sequence of an object and thereby completely describe its state.\nWe create a new object ins_A of class Protein. To this end, we call the class name like a function and supply the arguments required by the init method. Once the object ins_A has been created, we may access its attributes ([object name].[attribute name]).\nins_A = Protein(name=\"insulin A chain\", sequence=\"GIVEQCCTSICSLYQLENYCN\")\nprint(ins_A.name)\nprint(ins_A.sequence)\nprint(type(ins_A))\nThe built-in function type() tells us the class from which ins_A has been derived.\nYou may wonder what happened to the first parameter (self) of __init__(). Why did we only specify two arguments (which were obviously assigned to the parameters name und sequence) when we instantiated the insulin object? Each instance method must be defined with at least one parameter (commonly called self), which refers to the current instance. However, we must not pass an argument to this parameter when invoking the instance method – Python supplies the appropriate value “automatically”.\n\n\n\nLet’s add a method to our class. (Simply insert the definition of mutate() into your file simple_protein.py. Mind the correct indentation level!)\nclass Protein:\n    def __init__(self, name, sequence):\n        self.name = name\n        self.sequence = sequence\n\n    # only add the following lines to your file\n    def mutate(self, pos, residue):\n        self.sequence = self.sequence[:pos] + residue + self.sequence[pos+1:]\nThe method mutate() creates a point mutation by replacing the amino acid at position pos by residue.\nins_A = Protein(\"insulin A chain\", \"GIVEQCCTSICSLYQLENYCN\")\nprint(ins_A.sequence)\n\nins_A.mutate(2, \"W\")\nprint(ins_A.sequence)\nmutate() works as expected: It changed the third residue (i.e., valine with index 2) to tryptophane.\nIn the following sections, we will learn about classes that are available from the standard library."
  },
  {
    "objectID": "python3.html#regular-expressions",
    "href": "python3.html#regular-expressions",
    "title": "Python Unit 3",
    "section": "Regular expressions",
    "text": "Regular expressions\n\nIntroduction\nThe re module (from the standard library) implements classes and functions for handling regular expressions. As you might remember from the bash course, a regular expression (“regex”) is a string that defines a search pattern and thereby describes sets of other strings.\nThe re module is quite comprehensive. Here, we only present some of its functions; for further information, please consult the documentation and the article Regular Expression HOWTO.\nfindall() searches for all non-overlapping occurrences of a regular expression (first argument) in a string (second argument) and returns all matches as list.\nfrom re import findall\n\nfindall(r\".ython\", \"Python or rather Jython?\")\nIt is recommended to define the regular expression by using a raw string (i.e., a string that includes a r immediately left of the opening quote). Within a raw string, the backslash is not interpreted as escape character, but as an actual backslash. You will see below why this approach is advantageous.\n\n\nSyntax\nPython’s syntax for regular expressions is similar to the bash syntax:\n\nThe dot . denotes an arbitrary character (see example above).\nCharacter classes are assembled by surrounding a list of characters in brackets.\nfindall(r\"H[au]nd\", \"Hand Hund Hend\")\nYou may also specify a range of characters …\nfindall(r\"H[a-t]nne\", \"Hanne Henne Hunne\")  # characters a to t\n… or exclude certain characters.\nfindall(r\"H[^e]nne\", \"Hanne Henne Hunne\")   # all characters except e\nSeveral predefined character classes are available, such as \\d (all decimal numbers) and \\w (all alphanumeric characters, including the underscore). If you want to use these classes, raw strings are particularly useful:\nfindall(\"\\\\d\\\\w\", \"this is 1a\")  # many backslashes, right?\nfindall(r\"\\d\\w\", \"this is 1a\")   # better!\nQuantifiers following a character indicate how often this character may appear.\ntarget = \"bt bat baat baaat baaaat baaaaaaaaat\"\nfindall(r\"ba*t\", target)     # zero or more times\nfindall(r\"ba+t\", target)     # one or more times\nfindall(r\"ba?t\", target)     # zero or once\nfindall(r\"ba{3}t\", target)   # exactly three times\nfindall(r\"ba{2,}t\", target)  # at least two times\nfindall(r\"ba{,3}t\", target)  # up to three times\nfindall(r\"ba{2,4}t\", target) # two to four times\nAlternatives search for one of two different strings.\nfindall(r\"one|two\", \"one two three\")\nAnchors restrict matches to the start or end of a string:\nfindall(r\"^a..\", \"auf dem Haus\")  # anchor at the start\nfindall(r\"a..$\", \"auf dem Haus\")  # anchor at the end\nGroups are created by parentheses surrounding one or more characters. Groups may be modified by a quantifier and allow to extract parts of a match:\nfindall(r\"animal: (\\w+) (\\w+)\", \"animal: Mus musculus (mouse)\")\n\n\n\nPattern objects\nFunctions like findall() are useful for simple searches. For more complex cases, we prefer to create a pattern object from a regular expression and then use its methods.\nfrom re import compile\n\np = compile(r\"animal: (\\w+) (\\w+)\")\ntype(p)\nprint(p.pattern)  # attribute: regex used for searching\nprint(p.groups)   # attribute: number of groups\nThe pattern object has a method search() that searches for matches in a string and returns a match object upon success.\nm = p.search(\"animal: Mus musculus (mouse)\")\ntype(m)\nLet’s have a closer look at the match object:\nm.groups()  # tuple with found groups\nm[0]        # whole match\nm[1]        # first group\nm.span()    # start and end index of the whole match\nm.start(2)  # start index of the second group\nm.end(1)    # end index of the first group"
  },
  {
    "objectID": "python3.html#reading-and-writing-files",
    "href": "python3.html#reading-and-writing-files",
    "title": "Python Unit 3",
    "section": "Reading and writing files",
    "text": "Reading and writing files\n\nHow to read individual characters\nBy reading user input via input() or from command line arguments (sys.argv) and by displaying output on the console (print()), a program may interact with the user. However, as soon as a program has to read large datasets, it it will become infeasible to enter those data manually. Thus, Python is able to read files existing files and to create new files and write contents to them.\nPlease copy the file codon_table.csv from the folder /resources/week2 into the folder python3 in your home directory and have a look at its first five lines:\nAAA,Lys,K,Lysine\nAAC,Asn,N,Asparagine\nAAG,Lys,K,Lysine\nAAT,Asn,N,Asparagine\nACA,Thr,T,Threonine\nThis file apparently represents a codon table, where an amino acid is specified for each base triplet. We open the file by using the built-in function open(), which returns a file object:\nf = open(\"codon_table.csv\", \"r\")\nf\nThe second argument of open() sets the file access mode – here, we only want to read the file. Python treats an opened file as a data stream, i.e., a (one-dimensional) sequence of data (in our case, characters) that can be accessed randomly.\nPython may read from a file in the following manner: Immediately after a file has been opened, the current stream position points to the first character (index 0), as the method tell(), well, tells us:\nf.tell()\nWe read the first 30 characters via read() and store them in the variable s:\ns = f.read(30)\ns\nThese 30 characters comprise the first line and part of the second line. After the reading operation, the stream position lies at the 31st character (index 30):\nf.tell()\nWe may, for example, go back to index 15 and read ten characters, or jump forward to index 100 and read two characters:\nf.seek(15)\nf.read(10)\nf.tell()\n\nf.seek(100)\nf.read(2)\nf.tell()\n\n\nHow to read a file line by line\nIn many cases, we will not need random access to the file. Since text files generally are composed of lines, they are usually read line by line (method readline()):\nf.seek(0)\nl1 = f.readline()\nl1\n\nl2 = f.readline()\nl2\nf.tell()\nThe strings l1 and l2 now contain the first and second line of the file, respectively, including the end of line character \\n. The stream position points to the first character in the third line. Note: Unfortunately, the end of a line is marked by different characters depending on the operation system. While Linux uses \\n (line feed), Windows uses \\r\\n (carriage return plus line feed), and older versions of operating systems on Mac even used \\r. Thus, you may run into problems if you process a file that has been created in Windows on Linux.\nFortunately, we don’t have to repeatedly call readline() to eventually read all files from: A file object may be iterated line by line, which facilitates reading within a for loop:\nf.seek(0)\nfor line in f:\n  print(line)\nEven more simply, we may save all lines in a list via readlines():\nf.seek(0)\nall_lines = f.readlines()\nall_lines\nIf we don’t need a file any longer, we must close it:\nf.close()\n\n\nHow to write to a file\nIn order to be able to write to a file, we have to open it with the respective access mode:\nf = open(\"some_lines.txt\", \"w\")\nNow the method write() allows us to write strings to the file:\nf.write(\"First line\\n\")\nf.write(\"Second line\\n\")\nIf we wish to write a collection of strings (e.g., a list of strings), the method writelines() allows us to do so. Attention: Python will write the list elements one after each other to the file, without inserting a new line character. Thus, if the list elements represent individual lines, we have to add an explicit newline character to the list elements:\nlines = [\"three\\n\", \"four\\n\", \"five\\n\"]\nf.writelines(lines)\nOnce we are done, we have to close the file. This is especially important after we have written data to the file, since Python may postpone writing operations. close() ensures that any pending operations are finished.\nf.close()\nFinally, have a look at the created file (cat).\n\n\nContext objects\nContext objects make file access even simpler. Instead of opening, reading/writing, and closing, a with block is used:\nwith open(\"codon_table.csv\", \"r\") as f:\n    all_lines = f.readlines()\n\nfor line in all_lines:\n    print(line)\nCreate a context object by writing - keyword with - function that returns a context object (here: open()) - keyword as - name for the context object (here: f) - colon - indented statements (suite)\nWithin the suite, the context object is defined (in our example, the open file is available for reading). As soon as the control flow exits the suite, Python makes sure that the context object is deinitialized (in the case of files, any pending writing operations are executed, and the file is closed)."
  },
  {
    "objectID": "python3.html#exercises",
    "href": "python3.html#exercises",
    "title": "Python Unit 3",
    "section": "Exercises",
    "text": "Exercises\nStore all files that you generate for unit 3 in the folder python3 in your home directory.\n\nExercise 3.1 (4 P)\nYou have successfully solved this exercise as soon as you have worked through this unit. In particular, the folder python3 must contain the following files, which you have created in the course of this unit:\n\ncodon_table.csv\nsimple_protein.py\nsome_lines.txt\n\n\n\nExercise 3.2 (6 P)\nCreate a class Protein with the following properties:\n\nThe init method requires the arguments name, uniprot_id, and sequence, which are stored in attributes of the same name.\nThe method get_length returns the number of amino acids in the protein.\nThe method contains has one parameter peptide and returns True if the protein sequence contains the given peptide sequence.\nThe method get_mw returns the molecular weight of the protein. The method has an optional parameter disulfides that specifies the number of disulfide bridges.\n\nThe molecular weight of a protein is given by the following formula:\nsum of the masses of the amino acid residues\n+ mass of a water molecule\n- 2 * mass of hydrogen * number of disulfide bridges\nPlease use the following masses:\nAA_MASS = dict(\n    G=57.05132,\n    A=71.0779,\n    S=87.0773,\n    P=97.11518,\n    V=99.13106,\n    T=101.10388,\n    C=103.1429,\n    L=113.15764,\n    I=113.15764,\n    N=114.10264,\n    D=115.0874,\n    Q=128.12922,\n    K=128.17228,\n    E=129.11398,\n    M=131.19606,\n    H=137.13928,\n    F=147.17386,\n    R=156.18568,\n    Y=163.17326,\n    W=186.2099\n)\n\nWATER_MASS = 18.01528\nH_MASS = 1.00784\nStore the class in exercise_3_2.py.\nYou may check that your program works correctly by using the following exemplary calls:\ngalanin = Protein(\"Galanin\", \"P22466\", \"GWTLNSAGYLLGPHAVGNHRSFSDKNGLTS\")\nprint(type(galanin))\n#> <class '__main__.Protein'>\n\nprint(galanin.get_length())\n#> 30\n\nprint(galanin.contains(\"CGSHLV\"))\n#> False\n\nprint(galanin.get_mw())\n#> 3157.4102999999996\n\n\ninsulin_B = Protein(\"Insulin B chain\", \"P01308\", \"FVNQHLCGSHLVEALYLVCGERGFFYTPKT\")\nprint(insulin_B.get_length())\n#> 30\n\nprint(insulin_B.contains(\"CGSHLV\"))\n#> True\n\nprint(insulin_B.get_mw(disulfides=1))\n#> 3427.9056799999994\n\n\nExercise 3.3 (6 P)\nImplement a function read_masses which reads a table of atomic weights.\n\nThe function has a single parameter, which receives the name of the file containing the table.\nA table in CSV format is provided (/resources/week2/average_mass.csv), whose first five lines read\nH,1.008\nHe,4.0026\nLi,6.94\nBe,9.0122\nB,10.81\nEach line contains two records separated by a comma: The element symbol and the average atomic mass. Therefore, you may process each line with a regular expression containing two groups.\nThe function should return a dict, where element symbols and masses are the key-value pairs.\n\nStore the function in exercise_3_3.py.\nYou may check that your program works correctly by using the following exemplary calls:\nm = read_masses(\"average_mass.csv\")\nprint(m[\"N\"])\n#> 14.007\n\nprint(m[\"S\"])\n#> 32.06\n\nprint(2 * m[\"H\"] + m[\"O\"])\n#> 18.015\n\n\nExercise 3.4 (5 P)\nImplement a function calculate_mass, which calculates the mass of a chemical compound. The function is called with a string that contains the molecular formula (e.g., \"C6 H12 O6\" or \"C Cl4\") and returns the mass as a float.\nHints:\n\nExtract individual element symbols and their counts via a regular expression containing two groups. The first group should match one uppercase letter followed by an optional lowercase letter. The second group should match any number of digits.\nReuse your solution for exercise 3.3, which should provide a dict containing atomic masses. You may import Python files like any module (e.g., from exercise_3_3 import read_masses).\n\nStore the function in exercise_3_4.py.\nYou may check that your program works correctly by using the following exemplary calls:\nprint(calculate_mass(\"C6 H12 O6\"))\n#> 180.156\n\nprint(calculate_mass(\"H2 O\"))\n#> 18.015\n\nprint(calculate_mass(\"C34 H46 Cl N3 O10\"))\n#> 692.203"
  },
  {
    "objectID": "python1.html",
    "href": "python1.html",
    "title": "Python Unit 1",
    "section": "",
    "text": "To use Python, please connect to Corso via ssh; on this virtual machine, all required programs have been installed.\nExecute the following statements in Python’s interactive mode. Try to understand the result of each statement. If you encounter any difficulties, please do not hesitate to contact your course instructor.\n\n\nNumeric types represent numbers.\n42      # the integer number forty-two\n3.1415  # a decimal number (float) that approximates pi\nThe hash sign # starts a comment, so Python will ignore all remaining characters on the line. (Thus, you may omit all comments when you enter the following code snippets into the Python interpreter!).\nNumbers may be manipulated via arithmetic operators:\n1 + 2    # addition\n7 - 4    # subtraction\n5 * 6    # multiplication\n54 / 7   # division\n10 % 4   # modulo – returns remainder\nThe assignment operator assigns a name to a value:\na = 343\nb = 14\nNow, the name (also called variable) may be used instead of the value in any statement:\na\na + b\nVariable names may comprise an arbitrary number of letters, digits, and underscores. However, a name must not start with a digit, and certain keywords (e.g., if and for) are disallowed as names.\nx = 1            # ok\nfirst_value = 1  # ok\nnumber5 = 1      # ok\n2much = 1        # syntax error – name starts with a digit\nfor = 1          # syntax error – for is a keyword\nLet’s calculate the circumference and area of a circle with radius 5:\n# do the math\npi = 3.1415792\nradius = 5\ncircumference = 2 * radius * pi\narea = (radius ** 2) * pi\n\n# print results\ncircumference\narea\nWe added explicit parentheses around radius ** 2 to indicate that Python should first calculate the power and then the product. (Actually, we could have omitted these parentheses, since the precedence of exponentiation is higher than the one of multiplication.) However, parentheses are required if the default operator precedence should be changed.\n3 * 5 + 8  # equivalent to (3 * 5) + 8\n3 * (5 + 8)\nWhen in doubt, always use parentheses to structure your calculations! Moreover, never distract from the actual order of calculations by using spaces like\n3  *  5+8  # might imply that 5 and 8 are added first\n\n\n\nThere are only two Boolean values: True and False. Boolean types typically arise when using comparison operators:\n3 > 2    # greater than\n7 < 4    # less than\n10 >= 8  # greater than or equal\n2 <= 2   # less than or equal\n5 == 5   # equality\n10 != 9  # inequality\nLogical operators connect Boolean values to obtain new Booleans.\n(2 < 3) and (15 / 4 > 1)  # conjunction, true if both operands are true\n(5 != 5) or (12 >= 13)    # disjunction, true if at least one operand is true\nnot (5 < 7)               # negation changes true to false and vice versa\n\n\n\nA string is a sequence of Unicode characters enclosed in single or double quotes.\nstr_a = \"a string\"\nstr_b = 'also a string'\nstr_c = \"a string with 'single' quotes\"\nYou may also use multiline strings, which must be enclosed in triple quotes.\n'''a\nmulti-\nline\nstring'''\nString concatenation is done via the + operator:\nstr_a + str_b\nSince strings are sequences of characters, you can access a single character within a string by indexing.\nenzyme = \"adenylyl cyclase\"\nenzyme[0]    # first character\nenzyme[3]    # fourth character\nenzyme[-2]   # second character counting from the end of the string\nenzyme[2:8]  # substring from position 2 (included) to position 8 (excluded)\nPlease note:\n\nPython uses zero-based indexing, i.e., the first element has index 0.\nThe last line above demonstrates slicing [start index : end index], which yields a substring. The character at the start index is included, while the character at the end index is excluded (!).\n\nBoth start index and end index are optional:\nenzyme[:4]   # substring up to position 4 (excluded)\nenzyme[9:]   # substring starting at position 9 (included)\nenzyme[:]    # a copy of the whole string\nenzyme[-3:]  # substring starting at position 3 counting from the end\n\n\n\nPython also knows a None type, which explicitly denotes the “nothing”:\nnothing = None\nnothing\nThe is operator checks whether a variable is None (do not use a comparison operator in this case):\nnothing is None  # preferred\nnothing == None  # avoid"
  },
  {
    "objectID": "python1.html#input-and-output",
    "href": "python1.html#input-and-output",
    "title": "Python Unit 1",
    "section": "Input and output",
    "text": "Input and output\nUse the print() function to display output on the screen.\nprint(\"Hello world!\")\nprint(3 + 5)\nBy contrast, the input() function reads values supplied by the user:\nvalue = input(\"Please enter any value: \")\nvalue\nAfter calling input(), Python reads an arbitrary number of characters until the user presses Enter.\nNote that input() always reads a string. Thus, the following program will not work as expected:\nnumber = input(\"Please enter a number: \")\nprint(number + 10)  # a string cannot be added to an integer!\nIf we plan to use the entered value for calculations, we must convert it to a numeric type via int() or float():\nx = \"10\"  # x is the string \"10\"\nx * 2     # error!\n\ny = int(x)  # convert the string \"10\" to an integer 10\ny * 2       # this works!\n\na = float(\"2.3\")  # a is now the float 2.3\na / 5.6           # this works!\nThe following program asks the user to enter two numbers and then calculates their product. Store these statements in the file product.py and execute this file with Python (python product.py)! (To do so: exit the python console by typing exit() or the key combination Ctrl-D, then open and edit the file in a text editor such as nano)\nprint(\"Calculate the product of two numbers\")\n\na = input(\"First number: \")\na = float(a)\n\nb = input(\"Second number: \")\nb = float(b)\n\nprint(\"The result is\", a * b)"
  },
  {
    "objectID": "python1.html#command-line-arguments",
    "href": "python1.html#command-line-arguments",
    "title": "Python Unit 1",
    "section": "Command line arguments",
    "text": "Command line arguments\nA Python program may also process values supplied on the command line (similar to a shell command). To enable this functionality, we have to import the sys module (unit 2 explains modules in more detail). We create a Python script arguments.py containing the following lines:\nfrom sys import argv\n\nprint(argv)\nprint(argv[0])\nprint(argv[1:])\nWe then execute the script as follows:\npython arguments.py a 12 third_argument\nThe program prints three lines that tell us:\n\nargv is a list with four elements. (The list type will be treated in unit 2. For now, you only need to know that you may access the elements of a list like characters in a string: Variable name followed by the index in brackets.)\nThe first element argv[0] contains the name of the script that was called ('arguments.py').\nThe remaining elements argv[1:] contain the command line arguments in the given order.\n\nBy using command line arguments, we may calculate the product of two numbers as shown below:\nfrom sys import argv\na = float(argv[1])\nb = float(argv[2])\nprint(\"The result is\", a * b)\nStore these statements in product2.py and execute the program:\npython product2.py 35 10"
  },
  {
    "objectID": "python1.html#exercises",
    "href": "python1.html#exercises",
    "title": "Python Unit 1",
    "section": "Exercises",
    "text": "Exercises\nEach unit concludes with several exercises which you should solve on your own. Your solutions will be graded, and the scores will be used to obtain your final grade for the course. The maximum number of points for the correct solution of each exercise is indicated.\nStore all files that you generate for unit 1 in the folder python1 in your home directory.\n\nExercise 1.1 (3 P)\nYou have successfully solved this exercise as soon as you have worked through this unit. In particular, the folder python1 must contain the following files, which you have created in the course of this unit:\n\nproduct.py\narguments.py\nproduct2.py\n\n\n\nExercise 1.2 (2 P)\nWrite a Python program that executes the following statements consecutively. Store the program in exercise_1_2.py.\n\nStore the integer 32 in the variable z and the float 2.5 in the variable a.\nStore the product of z and a in the variable b.\nDivide a by 8 and store the result in a.\nShow whether a is greater than b (here, the program should print a single Boolean value.)\nShow whether the sum of z and 11 is unequal to 44 (again, only print a single Boolean value).\n\n\n\nExercise 1.3 (2 P)\nWrite a program exercise_1_3.py that prompts the user to enter three numbers and then displays whether the division of the first number by the second number yields a remainder that is equal to the third number.\nAn exemplary run of the program may yield the following output:\n$ python exercise_1_3.py\ndividend: 10\ndivisor: 4\nremainder: 2\nTrue\nThe user entered the three values 10, 4, and 2; subsequently, the program printed True.\nA different run of the program may look like\n$ python exercise_1_3.py\ndividend: 835\ndivisor: 111\nremainder: 20\nFalse\nIt does not matter whether your program prints anything in the input lines (such as “dividend:” above). However, it is important that the last printed line contains a single Boolean value that has been calculated correctly.\n\n\nExercise 1.4 (3 P)\nWrite a program exercise_1_4.py that reads four command line arguments. (Below, these arguments are called dna, x, a, e.). The first argument is a string of arbitrary length which represents a DNA sequence. Arguments 2 to 4 are integers. The program should print two lines:\n\nThe first line contains the x-th base from the left in dna.\nThe second line contains the subsequence of dna that starts two bases before the position given by a and ends at the position given by e.\n\nBases are numbered starting from one (thus, the first base in the sequence is actually numbered “1”).\nYou may check that your program works correctly by using the following exemplary calls:\n                          x  a   e\n                          ↓  ↓   ↓\n$ python exercise_1_4.py AGCTATAGTAATCCAAT 2 5 9\nG\nCTATAGT\n\n                               a     x      e\n                               ↓     ↓      ↓\n$ python exercise_1_4.py ATCTACGCGATATCGCGATAGCCGATGCTGACGACTGACTTGACG 13 7 20\nT\nACGCGATATCGCGATA"
  },
  {
    "objectID": "python2.html",
    "href": "python2.html",
    "title": "Python Unit 2",
    "section": "",
    "text": "The Python interpreter executes the statements in a Python script one by one, and quits after the last statement.\na = 4\nb = 9\nc = 5\nmean = (a + b + c) / 3\nprint(mean)\nEvidently, this basic flow of control only allows you to write the most basic programs. Therefore, Python supports compound statements that alter the control flow.\nNote: You may run all of the following examples in interactive mode. However, if you are writing a compound statement, entering several indented lines may be tedious. Thus, you might prefer to create one Python script per example (such as func_test.py) and then run this script (e.g., python func_test.py).\n\n\nCall a function by writing\n\nfunction name\nleft parenthesis\narguments separated by commas\nright parenthesis\n\nWe already encountered print(), a so-called built-in function that prints its argument(s) to the standard output (stdout).\nprint(\"Hello world!\")\nDefine a function by writing\n\nkeyword def\nfunction name\nleft parenthesis\nparameters separated by commas\nright parenthesis\ncolon\nindented statements (suite)\n\nThe following function calculates the mean of three numbers:\ndef mean_of_three(a, b, c):\n    result = (a + b + c) / 3\n    return result\n\nm = mean_of_three(5, 8, 2)\nprint(m)\nA function may pass values to the caller by using the return statement. In the example above, Python assigns the return value to the variable m.\n\nA statement such as return value1, value2, value3 tells a function to return several values.\nA function that lacks a return statement implicitly returns None.\n\nIn order to correctly use functions, we need to understand the difference between parameters and arguments:\n\nA parameter (also called “formal parameter”) is part of the function definition and specifies the number (and sometimes also the type) of input values the function may receive.\nAn argument (also called “actual parameter”) is the value that is passed to a function when it is called.\n\nWhen defining a function, we need to distinguish between required and optional parameters:\n\nA required parameter must receive a value when the function is called.\nAn optional parameter may be omitted when the function is called. In this case, a default value that was specified in the function definition is assigned to the parameter.\n\nBelow, we define an exponential function. The parameter exponent is required; by contrast, base is optional, with a default value of 2.71828.\ndef exp(exponent, base=2.71828):\n    return base ** exponent\n\nprint(exp(4))  # equal to exp(4, 2.71828)\nprint(exp(4, 10))\nWhen calling a function, we need to distinguish between positional and keyword arguments:\n\nA positional argument is assigned to a parameter based on its position.\nA keyword argument is assigned to a parameter based on its key.\n\nprint(exp(4, 10))                # 4 -> exponent, 10 -> base\nprint(exp(base=10, exponent=4))  # 10 -> base, 4 -> exponent\n\n\n\nif statements will execute a block of code if and only if a condition is true:\nn = -1\n\nif n < 0:\n    print(n, \"is negative\")\nCreate an if statement by writing\n\nkeyword if\ncondition (an expression that yields a Boolean value)\ncolon\nindented statements (suite)\n\nPython executes the code block following the if statement if the condition is true. If Python should also do something if the condition is false, you must add an else block:\nn = 5\n\nif n < 0:\n    print(n, \"is negative\")\nelse:\n    print(n, \"is positive\")\nelif blocks allow you to chain if statements, i.e., to test an arbitrary number of conditions and execute a distinct set of statements for each condition. Store the following code in test_sign.py and execute the file with Python:\ndef test_sign(n):\n    if n < 0:\n        return f\"{n} is negative\"\n    elif n > 0:\n        return f\"{n} is positive\"\n    else:\n        return f\"{n} is zero\"\n\nprint(test_sign(102))\nprint(test_sign(-12))\nprint(test_sign(0))\nf\" ... \" is a so-called f-string (“formatted string literal”). An f-string behaves like a normal string, but each part enclosed in curly braces is interpreted as Python statement whose result is inserted into the string.\nf\"An addition: {2+3}\"\n\n\n\n\n\nA while loop executes its suite as long as the given condition is true. Create such a loop by writing\n\nkeyword while\ncondition (an expression that yields a Boolean value)\ncolon\nindented statements (suite, loop body)\n\nStore the following code in calc_powers.py and execute the file with Python:\ni = 1\n\nwhile i < 10000:\n    i = i * 2\n    print(i)\nTypically, the condition will become false after several iterations of the loop body. Above, the variable i receives a new value whenever the loop body is run.\n\n\n\nIn Python, a for loop is a so-called iterative loop, since it executes the same code block once for each value in a sequence and may access the current element within the loop body.\nCreate a for loop by writing\n\nkeyword for\nloop variable\nkeyword in\niterable object (e.g., string or list)\ncolon\nindented statements (suite, loop body)\n\nfor letter in \"Python\":\n    print(letter)\nThe loop above is executed six times, and during each run, the loop variable letter contains a different character of the string \"Python\" (i.e., the values \"P\", \"y\", \"t\", \"h\", \"o\", and \"n\").\nSometimes we wish to iterate over a long sequence of numbers. It would be cumbersome if we had to explicitly write a list containing the numbers from, say, 0 to 10000 – there must be a simpler approach, right? Indeed, there is the built-in range() function, which generates a sequence of numbers.\nDepending on the numbers of arguments passed to range(), it will return4\n\na sequence of integers from 0 to a final value (excluded)\nfor i in range(10):\n    print(i)  #> 0, 1, …, 9\na sequence of integers from an initial value (included) to a final value (excluded)\nfor i in range(2, 7):\n    print(i)  #> 2, 3, 4, 5, 6\na sequence of integers as above, using the third argument as step size:\nfor i in range(20, 3, -3):\n    print(i)  #> 20, 17, 14, 11, 8, 5\n\n\n\n\n\nModular programming is a technique that allows to split code into several files, each of which contains related functions and data types. Thereby, code may easily be reused, since a function\n\nhas to be implemented only once in a module (also called package)\nand then may be used by every program that imports this module.\n\nFor instance, the math module defines common mathematical functions. (math is part of the Python standard library, whose modules are available on each Python installation. Other modules must be installed by the user.)\nThe keyword import imports a module and creates a namespace with the same name, which allows us to call a function from the module as follows:\n\nnamespace\n.\nfunction name\n\nimport math\n\nmath.factorial(7)\nWe also may select a different name for the namespace upon importing:\nimport math as mathematics\n\nmathematics.factorial(7)\nMoreover, individual (or all) functions of a module may be imported into the global namespace:\nfrom math import factorial\n\nfactorial(7)\nTo increase readability of your code, you should place all import statements at the top of your Python script."
  },
  {
    "objectID": "python2.html#data-structures",
    "href": "python2.html#data-structures",
    "title": "Python Unit 2",
    "section": "Data structures",
    "text": "Data structures\n\nLists\nLists belong to the class of compound data types, which serve as a “collection” of other data types. Lists are created by enclosing comma-separated elements in brackets. For instance, the following list comprises the first eight prime numbers:\nprimes = [2, 3, 5, 7, 11, 13, 17, 19]\nprimes\nIndexing and slicing work as explained for strings (see unit 1), returning a single element or a new list containing the sliced elements, respectively:\nprimes[3]\nprimes[2:5]\nSince lists are mutable, you may change their elements:\nprimes[3] = 100\nprimes\nThe built-in function len() returns the number of elements in a list:\nlen(primes)\nThe elements of a list may be lists themselves, which yields nested lists:\nnested_list = [\n    [1, 2, 3],\n    [4, 5],\n    [6, 7, 8, 9]\n]\nnested_list\nIndexing and slicing also work for nested lists:\nnested_list[1]\nnested_list[1][2]\nnested_list[2][2:6]\nSince lists are objects (see unit 3), they may be manipulated by special functions called methods. Methods are called like functions, but refer to a given object. Thus, the syntax for calling a method is as follows:\n\nname of the object\nperiod\nthe name of the method\nleft parenthesis etc. (like a function call)\n\nHere are some of the methods supported by lists (check the contents of bases after every statement!):\nbases = [\"A\", \"G\", \"X\", \"Y\"]\nbases.append(\"Z\")         # append an element to the list\ndel bases[2]              # delete element with index 2\nl = bases.pop()           # remove the last element and return it\nbases.extend([\"T\", \"U\"])  # appends elements from another list\nbases.insert(1, \"C\")      # insert the element given by the second argument\n                          # at the index given by the first argument\nbases.reverse()           # reverse order of elements\nbases.clear()             # delete all elements\nImportantly, you may iterate over a list via a for loop:\nfor p in primes:\n  print(p)\n\n\nTuples\nTuples are similar to lists, since they also represent a sequence of items. In contrast to lists, however, tuples are immutable – once you have created a tuple, you can’t change it. Tuples support common list operations:\nbases = (\"A\", \"C\", \"C\", \"G\", \"T\")\n\"A\" in bases      # check whether the tuple contains an element\nbases[1:3]        # slicing\nlen(bases)        # number of elements\nmin(bases)        # smallest element\nmax(bases)        # largest element\nbases.count(\"C\")  # count the number of a given element\nbases.index(\"G\")  # find the index of a given element\n\n\nSets\nThe set is a sequential data type that represents a mathematical set – thus, sets are unordered. Both mutable and immutable variants are available (set and frozenset, respectively). We create a set by placing their elements between curly braces, or by converting from another sequential type:\nA = {2, 4, 5}        # variant 1: direct\nA1 = set([2, 4, 5])  # variant 2: converting a list\n\nA == A1              # are these sets equivalent?\nBesides adding and removing elements, you may also perform the classical set operations:\nB = {1, 2, 3, 4, 5}\nB.discard(5)  # remove element if it exists\nB.add(7)      # add element\nB.add(7)      # set does not change – each element must be unique!\n\nA | B  # union (OR)\nA & B  # intersection (AND)\nA - B  # difference\nB - A  # note that the difference is not commutative\nA ^ B  # symmetric difference (XOR)\n\n\nDictionaries\nDictionaries (“dicts”) are unordered collections of key-value pairs, where keys have to be unique. Create a dict\n\neither by separating key-value pairs by colons and enclosing comma-separated pairs with curly braces,\natom_names = {\"C\": \"carbon\", \"H\": \"hydrogen\", \"N\": \"nitrogen\"}\natom_names\nor by using the built-in function dict(), to which we supply the key-value-pairs as keyword arguments:\natom_names_2 = dict(C=\"carbon\", H=\"hydrogen\", N=\"nitrogen\")\natom_names_2\natom_names_2 == atom_names\n\nTypical dict operations include inserting, deleting, and – most importantly – searching:\natom_names[\"C\"]             # find the value associated with key \"S\"\natom_names[\"O\"] = \"oxygen\"  # insert a new key-value pair\ndel atom_names[\"H\"]         # delete the value associated with \"H\"\nYou may iterate over all key-value pairs in a dict via the .items() method and a for loop:\nfor key, value in atom_names.items():\n    print(key, value)"
  },
  {
    "objectID": "python2.html#exercises",
    "href": "python2.html#exercises",
    "title": "Python Unit 2",
    "section": "Exercises",
    "text": "Exercises\nStore all files that you generate for unit 2 in the folder python2 in your home directory.\n\nExercise 2.1 (4 P)\nYou have successfully solved this exercise as soon as you have worked through this unit. In particular, the folder python2 must contain the following files, which you have created in the course of this unit:\n\ntest_sign.py\ncalc_powers.py\n\n\n\nExercise 2.2 (4 P)\nImplement a function get_charge that checks whether an amino acid is positively charged (e.g., arginine), negatively charged (e.g., aspartate), or neutral (e.g., valine).\n\nThe function should be called with a single argument that specifies the amino acid using its single-letter abbreviation. Only the 21 eukaryotic proteinogenic amino acids should be considered.\nDepending on the charge, the function should return one of the strings \"positive\", \"negative\", or \"neutral\".\nIf the user does not supply a valid abbreviation, the function should return \"invalid input\".\n\nStore the function in exercise_2_2.py.\nYou may check that your program works correctly by using the following exemplary calls:\nprint(get_charge(\"D\"))\n#> \"negative\"\n\nprint(get_charge(\"F\"))\n#> \"neutral\"\n\nprint(get_charge(\"H\"))\n#> \"positive\"\n\nprint(get_charge(\"foo\"))\n#> \"invalid input\"\n\n\nExercise 2.3 (4 P)\nImplement a function count_bases that counts the number of purine and pyrimidine bases in a DNA or RNA sequence.\n\nThe first parameter of the function should be called sequence and is required. It will receive a list containing an arbitrary number of strings, each of which represents a nucleotide sequence.\nThe second parameter should be called purine and is optional, with a default value of True. If purine is true, the function should calculate the number of purines; otherwise, it should calculate the number of pyrimidines.\nThe function should return a single integer, i.e., the number of all purines/pyrimidines in all sequences.\n\nStore the function in exercise_2_3.py.\nYou may check that your program works correctly by using the following exemplary calls:\nprint(count_bases([\"ACCGGGTTTT\", \"TTAAAGGGGCCCCC\"], True))\n#> 11\n\nprint(count_bases([\"AA\", \"UUUU\", \"G\", \"CCCCCCCC\"], purine=False))\n#> 12\n\n\nExercise 2.4 (4 P)\nIf you code a lot, you will often use third-party packages and consult their documentation. This is what we will do in this exercise: Implement a function make_sequence that creates a random DNA or RNA sequence of a given length and calculates how often a given base appears in this sequence.\n\nThe first (required) parameter sets the sequence length.\nThe second (optional) parameter rna decides whether an RNA or DNA sequence should be created. This parameter has a Boolean type and is false by default.\nThe third (optional) parameter count_base names the base that should be counted (default: \"A\").\nThe function should return two values: (1) A string representing the created sequence, and (2) how often the specified base appears.\n\nSince the function should create the sequence randomly, you might consider to use the function choices() available in the random module. This module is part of the standard library – please read the documentation. You will also need the string method join() to convert the value returned by choices() into a string. Since string is a built-in data type, it is also documented in the standard library.\nStore the function in exercise_2_4.py.\nYou may check that your program works correctly by using the following exemplary calls:\nrandom.seed(42)\nprint(make_sequence(20, False, \"A\"))\n#> ('GACAGGTACAAGAAGGAGTA', 9)\n\nprint(make_sequence(15, rna=True, count_base=\"C\"))\n#> ('UGCAUCAAUGUGGUC', 3)\n\n\nExercise 2.5 (4 P)\nIn this exercise, you will create a command line program that calculates the similarity of two tissue samples by means of their expressed genes.\n\nThe program should process two command line arguments genes1 and genes2.\nEach argument specifices the genes that are expressed in the respective sample. Individual genes should be separated by semicolons (e.g., GENE1;GENE2;GENE3;GENE4). It does not matter whether a gene appears more than once. (To process the arguments, the string method split()may be useful – see documentation.)\nThe program should return three values, each on a separate line:\n\nthe number of (unique) genes detected in the first sample\nthe number of (unique) genes detected in the second sample\nthe similarity of the samples, which is measured by the Jaccard index.\n\n\nYou may check that your program works correctly by using the following exemplary calls:\n$ python exercise_2_5.py \"RAB5C;PITX2;ZNF222;LMTK2;LMTK2\" \"RAB5C;PABPC4;ZNF222;PKN1;PTMA\"\n4\n5\n0.2857142857142857\n\n$ python exercise_2_5.py \"THOC5;RAD23B;GPR31;PIRC85;PANO1\" \"THOC5;ATP1A2;GPR31;THOC5\"\n5\n3\n0.3333333333333333\n\n$ python exercise_2_5.py \"RAD23B\" \"RAD23B\"\n1\n1\n1.0"
  },
  {
    "objectID": "bash.html",
    "href": "bash.html",
    "title": "Bash",
    "section": "",
    "text": "The command ssh lets you connect to the cluster. Note: you will need VPN active to be able to connect.\nssh [username]@corso.came.sbg.ac.at\n# For example:\nssh nfortelny@corso.came.sbg.ac.at\nNext you will change your password. Make sure to remember this password which you will you throughout this course.\npasswd\nNow we are connected to the cluster. In the following we will explore this file system. Details will be explored in the next lecture of this course. For now, just execute the commands and see if you can make sense of the results.\nThe cluster has a file system like any computer. Currently you are in your home directory. The current “path” is shown by the following command\npwd\nYou can list the content of your home directory using\nls\nls -l\nYou can clear the terminal by typing\nclear\nNow, use the up- and down-arrows on your keyboard to look through the history of commands.\nNow create a directory:\nmkdir day1\nList content of the directory again:\nls\nls -l\nWhat does mkdir do? Bring up the manual (press “q” to exit the manual).\nman mkdir\nNow create some files. There are many ways to create a file.\n# Create an empty file in directory \"day1\"\ntouch day1/touch.txt\n\n# Write the text \"abcdefgh\" in a file.\necho \"abcdefgh\"  > day1/echo.txt\nList files again.\nls\nls -l\nTake a look at the files with content.\nhead day1/*"
  },
  {
    "objectID": "bash.html#files-and-file-systems-day-2",
    "href": "bash.html#files-and-file-systems-day-2",
    "title": "Bash",
    "section": "Files and file systems (Day 2)",
    "text": "Files and file systems (Day 2)\n\nNavigate the file system\nFirst, let’s clean up.\nclear\nGo to the home directory (absolute path).\ncd ~/\nls -l\npwd\nGo to the folder with all home directories (absolute path).\ncd /home\nls -l\npwd\nGo back to your home directory (absolute path).\ncd ~/\nls -l\npwd\nGo into the directory created yesterday (relative path - from your home directory).\ncd day1/\nls -l\npwd\nGo back one level (relative path - from the day1 folder).\ncd ../\nls -l\npwd\nLet’s create another folder (relative path - from your home directory). What does the -p stand for?\npwd\nmkdir -p day2/test/folder\npwd\nChange permissions in a file created in the above folder.\ntouch day2/test/folder/test.txt\nls -l day2/test/folder\n\nchmod 711 day2/test/folder/test.txt\nls -l day2/test/folder\n\nchmod 722 day2/test/folder/test.txt\nls -l day2/test/folder\n\nchmod 733 day2/test/folder/test.txt\nls -l day2/test/folder\n\nchmod 744 day2/test/folder/test.txt\nls -l day2/test/folder\n\nchmod 755 day2/test/folder/test.txt\nls -l day2/test/folder\n\nchmod 766 day2/test/folder/test.txt\nls -l day2/test/folder\n\nchmod 777 day2/test/folder/test.txt\nls -l day2/test/folder\n\nchmod 700 day2/test/folder/test.txt\nls -l day2/test/folder\n\nman chmod\nThe following table outlines permissions in chmod (https://en.wikipedia.org/wiki/Chmod).\n\n\n\nx\nPermission\nrwx\nBinary\n\n\n\n\n7\nread, write and execute\nrwx\n111\n\n\n6\nread and write\nrw-\n110\n\n\n5\nread and execute\nr-x\n101\n\n\n4\nread only\nr--\n100\n\n\n3\nwrite and execute\n-wx\n011\n\n\n2\nwrite only\n-w-\n010\n\n\n1\nexecute only\n--x\n001\n\n\n0\nnone\n---\n000\n\n\n\n\nExercises\n\nCreate a new folder called test2 within in the folder ~/day2.\nEnable full access to this folder for the owner of the folder, read access for the group, and no access for others\n\n\n\n\nGetting files\nMake sure you are in your home directory.\npwd\ncd ~/\n# same as \"cd \" or \"cd ~\", since the default value\n# for the dir argument is HOME (see \"man cd\")\n\npwd\nObtain the list of gRNAs.\n# move or copy?\nman mv\nman cp\n\n# now try it:\nmv /resources/week1/gRNAs.txt ~/\ncp /resources/week1/gRNAs.txt ~/\n\n# Why does mv not work? Look at file permissions:\nls -l /resources/week1/gRNAs.txt\nls -l ~/gRNAs.txt\nNow explore the copied file.\nhead gRNAs.txt\nhead -5 gRNAs.txt\ntail -5 gRNAs.txt\nless gRNAs.txt\nmore gRNAs.txt\n\n# Count the number of lines\nwc -l gRNAs.txt\n\nExercises\nCopy the file gRNAs.txt from your home directory into the folder day2. Then rename the copied file in this folder to gRNAs_exercise.txt.\n\n\n\nEditing in nano\nNow add a line at the end of the file gRNAs.txt that is located in your home directory, adding the gRNA sequence “ACTGACTG”. Use the nano editor for this purpose. To quit the nano-editor you need to press Ctrl+X. Then type y+Enter to save the changes. Nano commands are shown in the editor and can be found on the internet. A list is provided below.\nnano gRNAs.txt\nNano commands:\n\n\n\nCommand\nFunction\n\n\n\n\nctrl+r\nread/insert file\n\n\nctrl+o\nsave file\n\n\nctrl+x\nclose file\n\n\nalt+a\nstart selecting text\n\n\nctrl+k\ncut selection\n\n\nctrl+u\nuncut (paste) selection\n\n\nalt+/\ngo to end of the file\n\n\nctrl+a\ngo to start of the line\n\n\nctrl+e\ngo to end of the line\n\n\nctrl+c\nshow line number\n\n\nctrl+_\ngo to line number\n\n\nctrl+w\nfind matching word\n\n\nalt+w\nfind next match\n\n\nctrl+\\\nfind and replace\n\n\n\nNow use nano to modify the shell to make things prettier. To do so change the file .bash_profile. This file contains settings for each user (the naming is just by convention). It starts with a ., which for Linux means the file is hidden.\nnano ~/.bash_profile\nAdd the following lines to .bash_profile in nano, then exit the file and save it - see the commands above.\nif [ -x /usr/bin/dircolors ]; then\n    test -r ~/.dircolors && eval \"$(dircolors -b ~/.dircolors)\" || eval \"$(dircolors -b)\"\n    alias ls='ls --color=auto'\n    alias grep='grep --color=auto'\nfi\nThe changes we added to .bash_profile will come into effect next time you log in. To also activate them for your current login, you can source the file, executing the commands stored within.\nls -l *\nsource ~/.bash_profile\nls -l *\nAlso, notice the difference in ls commands to show hidden files (like .bash_profile).\nls -l\nls -al\n\n\nZipped files\nNow let’s download all human gene sequences from Ensembl. Download the file to your home directory.\nman wget\nwget http://ftp.ensembl.org/pub/release-103/fasta/homo_sapiens/cds/Homo_sapiens.GRCh38.cds.all.fa.gz\nIf the above fails, then you can also copy the file from the resources folder into you home directory.\ncp /resources/week1/Homo_sapiens.GRCh38.cds.all.fa.gz ~/\nTo make sure you have the entire file properly downloaded, compare the MD5 hash of the file. MD5 hash functions are a compact digital fingerprint of a file. The MD5 hash of the file should be b16d46bf09c3b8b7909624f1e6c414ce.\nmd5sum ~/Homo_sapiens.GRCh38.cds.all.fa.gz\nmd5sum /resources/week1/Homo_sapiens.GRCh38.cds.all.fa.gz\nHow large is this file?\ndu *\ndu -sh *\nHave a look at this file.\nhead Homo_sapiens.GRCh38.cds.all.fa.gz\nThis doesn’t look great. Remember to clean up your terminal.\nclear\nThe above file is zipped. Now unzip it.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz\n# This command will run through the entire file which is very long.\n# Press Ctrl+C to stop the command.\n\nman gunzip\n# -c --stdout --to-stdout\n#   Write output on standard output; keep original files unchanged.\n#   If there are several input files, the output consists of a sequence \n#   of independently compressed members. To obtain better compression,\n#   concatenate all input files before compressing them.\nAgain, remember to clean up your terminal.\nclear\nCan we use head on the unzipped output? Yes - this is done using a pipe.\n\n\nPipes\nLinux pipes enables you to pass the output of one command to another command.\n\n\n\nPipe command\nFunction\n\n\n\n\ncmd < file\nuse file as input for command cmd\n\n\ncmd > file\nwrite output to file\n\n\ncmd >> file\nappend output to file\n\n\ncmd 2> stderr\nwrite error output to file\n\n\ncmd &> file\nsend output and error to file\n\n\ncmd1 | cmd2\nsend output of cmd1 to cmd2\n\n\n\nLet’s have a look at the first few lines of this file.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head\nSome programs let you look at decompressed output, for example\nzless Homo_sapiens.GRCh38.cds.all.fa.gz\n\n# very similar to:\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | zless\nNow we can also count the number of lines in this file:\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | wc -l\n\nExercises\nCreate a folder called day2 in your home. Next place the following files into the folder day2, using pipes:\n\nStore the number of lines of Homo_sapiens.GRCh38.cds.all.fa.gz into the file lineNumber.txt.\nWrite the first 15 lines of Homo_sapiens.GRCh38.cds.all.fa.gz into the file lines1.txt.\nWrite the 31th to 35th line of Homo_sapiens.GRCh38.cds.all.fa.gz into the file lines2.txt.\nStore the size of Homo_sapiens.GRCh38.cds.all.fa.gz in Megabytes into the file size.txt."
  },
  {
    "objectID": "bash.html#patterns-and-regular-expressions-day-3",
    "href": "bash.html#patterns-and-regular-expressions-day-3",
    "title": "Bash",
    "section": "Patterns and regular expressions (Day 3)",
    "text": "Patterns and regular expressions (Day 3)\n\nFile pattern matches\nCommands can be executed on multiple files at the same time using pattern matches (we have used this already above).\nls -l\nls -l *\nls -l day*\nwc -l *\nwc -l *.gz\n\n\n\n\n\n\n\nDescription\nPattern\n\n\n\n\nMatch zero or more characters\n*\n\n\nMatch any single character\n?\n\n\nMatch any of the characters in a set\n[...]\n\n\nMatch zero or one occurrences of the patterns (extglob)\n?(patterns)\n\n\nMatch zero or more occurrences of the patterns (extglob)\n*(patterns)\n\n\nMatch one or more occurrences of the patterns (extglob)\n+(patterns)\n\n\nMatch one occurrence of the patterns (extglob)\n@(patterns)\n\n\nMatch anything that doesn’t match one of the patterns (extglob)\n!(patterns)\n\n\n\n\n\nSimple regular expressions\nRegular expressions can be executed on file names but also content within files. Below is the example from the PDF presented during the lecture. Note: The file sample needs to be copied to your home directory from the directory /resources/week1.\ncat sample\ngrep ^a sample\ngrep -E p\\{2} sample\ngrep \"a\\+t\" sample\nsed \"s/a/XXX/g\" sample\n\n\n\nDescriptions\nSymbol\n\n\n\n\nreplaces any character\n.\n\n\nmatches start of string\n^\n\n\nmatches end of string\n$\n\n\nmatches up zero or more times the preceding character\n*\n\n\nRepresent special characters\n\\\n\n\nGroups regular expressions\n()\n\n\nMatches up exactly one character\n?\n\n\n\n\n\nChecking the nucleotides in the Ensembl fasta file\nNow let’s use regulare expressions to explore the fasta file. Have a look at the first few lines.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -50\nWe expect all DNA sequences to be made up of A, C, T, and Gs. Now, we will verify this. First, we will get all DNA-sequences from this file, excluding lines starting with a > (in a FASTA files, these lines are the lines describing the sequence; see https://en.wikipedia.org/wiki/FASTA_format).\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \">\"\n\n# from \"man grep\":\n# -v Invert the sense of matching, to select non-matching lines.\nNext we will use tr to delete newline characters. This will place all sequences in one (very long) line.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \">\" | tr -d '\\n'\nNext we place every character on a different line.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \">\" | tr -d '\\n' | grep -o .\nFinally, we want to remove repetition, to only see the unique nucleotides. To do so, we have to first sort the lines and then make them unique.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \">\" | tr -d '\\n' | grep -o . | sort | uniq\n\n# what happens if we only make them unique?\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \">\" | tr -d '\\n' | grep -o . | head -20\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \">\" | tr -d '\\n' | grep -o . | head -20 | uniq\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \">\" | tr -d '\\n' | grep -o . | wc -l\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \">\" | tr -d '\\n' | grep -o . | uniq | wc -l\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \">\" | tr -d '\\n' | grep -o . | sort | uniq | wc -l\n\nExercises\n\nCreate a folder day3 in your home directory.\nCount the number of A, C, T, and G of the DNA sequences of the first 1000 lines of file Homo_sapiens.GRCh38.cds.all.fa.gz.\nStore each number in a file called nt_A.txt, nt_C.txt,… in the folder day3.\n\n\n\n\nReformatting the Ensembl fasta file\nNext, we will reformat the fasta file, such that every entry is on one line and the DNA sequence is at the end of the line.\nRemind ourselves of how this file looks like:\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500\nIn the original format, the > separates different entries and sequences are in the lines below the line with >. First, we will remove newline characters that separate the sequences. To remove the newline characters, we will use the sed command.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | sed -zE 's/([ACTG])\\n([ACTG])/\\1\\2/g'\nLet breack this up:\n\ns/// tells sed to substitute.\ns///g tells sed to substitue globally - replacing each occurance of x.\ns/x/y/g means we substitute x by y.\n([ACTG]) matches any of the four letters A, C, T, and G. The brackets () tell the regex to store the match for later (see \\1 and \\2 below). If we want to use this storing we need to use sed -E.\n\\n matches the newline.\n\\1 is going to be replaced by the first match within the first brackets (). Therefore, here it will be replaced by the nucleotide before the new line.\n\\2 is going to be replaced by the second match within the second brackets (). Therefore, here it will be replaced by the nucleotide after the new line.\nSo ultimately the nulceotide before and after the newline are stored, and then they are written again but without the newline.\n\nNext, we will remove the newline character that separates the sequence from the line with the entry information, which starts with >, and replace it with seq:.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | sed -zE 's/([ACTG])\\n([ACTG])/\\1\\2/g' | sed -z 's/\\n[^>]/ seq:/g'\nExplanation:\n\n[^>] means to NOT match >.\n\\n[^>] replaces all newline characters that are NOT before a >.\n\nWe developed the above approach on the first lines. Now run it an the full file. This may take a couple of minutes. The gzip command will compress the results. The > will store it in a new file GRCh38_reformatted.gz. The reformatted file should end up in your home directory.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | sed -zE 's/([ACTG])\\n([ACTG])/\\1\\2/g' | sed -z 's/\\n[^>]/ seq:/g' | gzip > GRCh38_reformatted.gz\nExplore the generated file.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | wc -l\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | grep \">\" | wc -l\ngunzip -c GRCh38_reformatted.gz | wc -l\nzless GRCh38_reformatted.gz\n\n\nIdentifying gRNA matches\nNow, with the newly formatted file, we can easily identify genes in the database that match a specific gRNA.\ngunzip -c GRCh38_reformatted.gz | head -30\nWe check that all entries have gene symbols:\ngunzip -c GRCh38_reformatted.gz | grep \"gene_symbol\" | head -30 \ngunzip -c GRCh38_reformatted.gz | grep -v \"gene_symbol\" | head -30 \n\n# remember: grep -v means to *not* match\nNext we extract those sequences matching the guide “TTAAGACA”:\ngunzip -c GRCh38_reformatted.gz | grep \"seq:[ACTG]*TTAAGACA\" | head -30 \nNow we extract the gene symbols of these matches. First we match all text (.*) from the beginning of the line (^) before the text gene_symbol and delete it.\ngunzip -c GRCh38_reformatted.gz | grep \"seq:[ACTG]*TTAAGACA\" | sed 's/^.*gene_symbol://g' | head -30\nThen we also remove all text after the gene symbol, in this case the space and everything (.*) after that until the end of the line ($).\ngunzip -c GRCh38_reformatted.gz | grep \"seq:[ACTG]*TTAAGACA\" | sed 's/^.*gene_symbol://g' | sed 's/ .*$//g'  | head -30\nFinally, we get unique gene IDs.\ngunzip -c GRCh38_reformatted.gz | grep \"seq:[ACTG]*TTAAGACA\" | sed 's/^.*gene_symbol://g' | sed 's/ .*$//g'  | sort | uniq\n\nExercises\nCreate the following files in the folder day3:\n\nExtract all entries with sequences matching the guide “GCGGTTTC” in the file guideMatch_GCGGTTTC.txt.\nWrite the count of entries with sequences starting with “TGC” into the file count_TGC.txt.\nWrite the count of entries of gene “MMP2” into the file count_MMP2.txt. Note: Do not count genes MMP20, MMP21,…\nWrite the count of unique genes whose symbol starts with “RPL” into the file count_RPL.txt.\nWrite the count of all unique protein coding genes into the file count_protein_coding.txt."
  },
  {
    "objectID": "bash.html#loops-and-variables-day-4",
    "href": "bash.html#loops-and-variables-day-4",
    "title": "Bash",
    "section": "Loops and variables (Day 4)",
    "text": "Loops and variables (Day 4)\n\nVariables\nVariables can hold information which can be passed to different programs.\nx=\"test variable\"\necho $x\necho $x | sed 's/a//g'\nNow we will write the gRNAs to test and the regexp patterns into variables.\nguide=TTAAGACA\necho $guide\npattern=\"seq:[ACTG]*${guide}\"\necho $pattern\ngunzip -c GRCh38_reformatted.gz | grep $pattern | head -30\ngunzip -c GRCh38_reformatted.gz | grep $pattern | sed 's/^.*gene_symbol://g' | sed 's/ .*$//g' | head -30\n\n\nLoops\nWe will use while loops. They have the following syntax:\nwhile [condition] do [something] done\nDifferent types of loops exist (https://ryanstutorials.net/bash-scripting-tutorial/bash-loops.php), but those are not important for this course.\nThe following loop starts with x = 1. It then repeats printing “Welcome … times” and adding +1 to x, until x is greater than 5 (while x is lower or equal to 5 $x -le 5).\nx=1\nwhile [ $x -le 5 ]\ndo\n  echo \"Welcome $x times\"\n  x=$(( $x + 1 )) # syntax to add a number to x\ndone\nImportantly, the loop is ONE construct. Thus when entering while [ $x -le 5 ], the terminal expects additional information, in particular do [...] done. While waiting for additional input, the terminal will start lines with >. Keep entering the do, etc in those lines. The final results will look like this:\n[user]@corso:~$ while [ $x -le 5 ]\n> do\n> echo \"Welcome $x times\"\n> x=$(( $x + 1 ))\n> done\nWelcome 1 times\nWelcome 2 times\nWelcome 3 times\nWelcome 4 times\nWelcome 5 times\nTry to make the above loop count to 10. Or from 10 to 5.\nHere are different ways to compare numbers. Assume variable a holds 10 and variable b holds 20 then:\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\n\n\n\n\n-eq\nChecks if the value of two operands are equal or not; if yes, then the condition becomes true.\n[ $a -eq $b ] is not true.\n\n\n-ne\nChecks if the value of two operands are equal or not; if values are not equal, then the condition becomes true.\n[ $a -ne $b ] is true.\n\n\n-gt\nChecks if the value of left operand is greater than the value of right operand; if yes, then the condition becomes true.\n[ $a -gt $b ] is not true.\n\n\n-lt\nChecks if the value of left operand is less than the value of right operand; if yes, then the condition becomes true.\n[ $a -lt $b ] is true.\n\n\n-ge\nChecks if the value of left operand is greater than or equal to the value of right operand; if yes, then the condition becomes true.\n[ $a -ge $b ] is not true.\n\n\n-le\nChecks if the value of left operand is less than or equal to the value of right operand; if yes, then the condition becomes true.\n[ $a -le $b ] is true.\n\n\n\nYou can also use nano to write the code above into a file (for example here: script.sh) and then use the following to execute it:\nbash script.sh\nWe can also loop through the content of a file.\nwhile read p; do\n  echo \"$p\"\ndone < gRNAs.txt\n\nExercise\nNow we will combine the above variables and loopes to test all guides in file gRNAs.txt against all DNA sequences in GRCh38_reformatted.gz. To do so you need the following steps (also see the hints below):\n\nUse the code above (under Variables) that matches guides against DNA sequences and extracts gene symbols for matched sequences.\nPlace this function into the loop that iterates through the file gRNAs.txt, using the while loop iterating through the file.\nStore all results (not just the top 30 coming from head -30) of each guide into a file that is named results_${guide}.txt. Place all files into a new folder day4 - ideally already within the loop.\nCheck a few examples by hand. Do you get the right genes? Do you get the correct number of genes for the guides?\n\nHint: To complete the exercise, you can use the following code to extract genes for one guide. Note: The guide needs to be defined first using guide=[...]\necho $guide\npattern=\"seq:[ACTG]*${guide}\"\necho $pattern\ngunzip -c GRCh38_reformatted.gz | grep $pattern | sed 's/^.*gene_symbol://g' | sed 's/ .*$//g' | sort | uniq\nPlace the above in the loop that iterates throught the gRNA file.\nwhile read guide; do\n  echo $guide\ndone < gRNAs.txt\nRemember: you need to save the result of the last line (gunzip ... | uniq) to a file results_${guide}.txt.\n\n\n\nComparing files\nHave a look at the files we generated.\ncd ~/day4\nls results_*.txt\nls -l results_*.txt\nhead results_*.txt\nwc -l results_*.txt\nNow let’s compare results in a pairwise manner. The command comm will provide the gene symbols unique to one or the other file, plus the intersection of both.\ncd ~/day4\ncomm results_AAGTTGGC.txt results_GCCATACA.txt\ncomm -12 results_AAGTTGGC.txt results_GCCATACA.txt\nThe count of genes in the overlap (intersection) can be stored in a new variable. To store results of an expression in a new variable, place the expression into parenthesis x=$().\ncd ~/\nguide1=AAGTTGGC\nguide2=GCCATACA\noverlap=$(comm -12 day4/results_${guide1}.txt day4/results_${guide2}.txt | wc -l)\necho \"$guide1 $guide2 $overlap\"\n\nExercise\nNow we will compare each pair of guides to test the overlap of genes. Place the result in the folder day4:\n\nUse one loop (iterating through all guides) within a second loop (also iterating through all guides) to compare the overlap between all pairs of guides.\nUse the comm command as shown above to extract the overlap, counting the number of genes, and writing the result into a file named overlap_${guide1}_${guide2}.txt.\n“Manually” check results, for example comparing to the example above (“AAGTTGGC” vs “GCCATACA”)."
  },
  {
    "objectID": "bash.html#useful-links",
    "href": "bash.html#useful-links",
    "title": "Bash",
    "section": "Useful links",
    "text": "Useful links\nLinux for bioinformatics\n\nhttps://bioinformaticsworkbook.org/Appendix/Unix/unix-basics-1.html#gsc.tab=0\nhttps://bioinformaticsworkbook.org/Appendix/Unix/UnixCheatSheet.html#gsc.tab=0\nhttps://bioinformatics.uconn.edu/unix-basics/#\nhttps://decodebiology.github.io/bioinfotutorials/\nhttps://www.melbournebioinformatics.org.au/tutorials/tutorials/unix/unix/\n\nGeneral linux commands\n\nhttps://www.thegeekstuff.com/2010/11/50-linux-commands/\n\nRegular expressions:\n\nhttps://www.guru99.com/linux-regular-expressions.html"
  }
]