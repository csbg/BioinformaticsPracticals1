[
  {
    "objectID": "python3.html",
    "href": "python3.html",
    "title": "Python Unit 3",
    "section": "",
    "text": "Python supports, amongst others, the object-oriented programming paradigm. While hundreds of books have been written on this paradigm, it is actually quite easy to grasp: Think of a program as a collection of objects that communicate with each other. Each object has\n\nattributes describing its state, and\nmethods that allow to change these attributes.\n\nBefore we can create an object, we first have to define a “blueprint” (class) for a certain type of object. Then, we may create one or more objects from this class via a process known as instantiation. Each of these objects will have the same set of attributes and methods, but the attributes will typically differ in their values.\nSince all those concepts may sound quite abstract at first, here’s a comprehensive example. We will create a class that represents proteins. Our implementation remains simple, but you will have the opportunity to add functionality in the exercises.\nAll statements of this section (i.e., the class definitions) should be stored in simple_protein.py.\n\n\nA protein is characterized by its name and amino acid sequence. Hence, the protein class needs at least two attributes:\nclass Protein:\n    def __init__(self, name, sequence):\n        self.name = name\n        self.sequence = sequence\nThe code above defines a new class:\n\nkeyword class\nclass name (here Protein)\ncolon\nindented statements (suite, class body)\n\nWe also define an init method, which must be named __init__() and is called by Python whenever a new object is instantiated from the class. In the body of the init method, we initialize the instance variables self.name and self.sequence. These variables store the name and sequence of an object and thereby completely describe its state.\nWe create a new object ins_A of class Protein. To this end, we call the class name like a function and supply the arguments required by the init method. Once the object ins_A has been created, we may access its attributes ([object name].[attribute name]).\nins_A = Protein(name=\"insulin A chain\", sequence=\"GIVEQCCTSICSLYQLENYCN\")\nprint(ins_A.name)\nprint(ins_A.sequence)\nprint(type(ins_A))\nThe built-in function type() tells us the class from which ins_A has been derived.\n\n\n\n\n\n\nImportant\n\n\n\nYou may wonder what happened to the first parameter (self) of __init__(). Why did we only specify two arguments (which were obviously assigned to the parameters name und sequence) when we instantiated the insulin object? Each instance method must be defined with at least one parameter (commonly called self), which refers to the current instance. However, we must not pass an argument to this parameter when invoking the instance method – Python supplies the appropriate value “automatically”.\n\n\n\n\n\nLet’s add a method to our class. (Simply insert the definition of mutate() into your file simple_protein.py. Mind the correct indentation level!)\nclass Protein:\n    def __init__(self, name, sequence):\n        self.name = name\n        self.sequence = sequence\n\n    # only add the following lines to your file\n    def mutate(self, pos, residue):\n        self.sequence = self.sequence[:pos] + residue + self.sequence[pos+1:]\nThe method mutate() creates a point mutation by replacing the amino acid at position pos by residue.\nins_A = Protein(\"insulin A chain\", \"GIVEQCCTSICSLYQLENYCN\")\nprint(ins_A.sequence)\n\nins_A.mutate(2, \"W\")\nprint(ins_A.sequence)\nmutate() works as expected: It changed the third residue (i.e., valine with index 2) to tryptophane.\nIn the following sections, we will learn about classes that are available from the standard library."
  },
  {
    "objectID": "python3.html#object-oriented-programming",
    "href": "python3.html#object-oriented-programming",
    "title": "Python Unit 3",
    "section": "",
    "text": "Python supports, amongst others, the object-oriented programming paradigm. While hundreds of books have been written on this paradigm, it is actually quite easy to grasp: Think of a program as a collection of objects that communicate with each other. Each object has\n\nattributes describing its state, and\nmethods that allow to change these attributes.\n\nBefore we can create an object, we first have to define a “blueprint” (class) for a certain type of object. Then, we may create one or more objects from this class via a process known as instantiation. Each of these objects will have the same set of attributes and methods, but the attributes will typically differ in their values.\nSince all those concepts may sound quite abstract at first, here’s a comprehensive example. We will create a class that represents proteins. Our implementation remains simple, but you will have the opportunity to add functionality in the exercises.\nAll statements of this section (i.e., the class definitions) should be stored in simple_protein.py.\n\n\nA protein is characterized by its name and amino acid sequence. Hence, the protein class needs at least two attributes:\nclass Protein:\n    def __init__(self, name, sequence):\n        self.name = name\n        self.sequence = sequence\nThe code above defines a new class:\n\nkeyword class\nclass name (here Protein)\ncolon\nindented statements (suite, class body)\n\nWe also define an init method, which must be named __init__() and is called by Python whenever a new object is instantiated from the class. In the body of the init method, we initialize the instance variables self.name and self.sequence. These variables store the name and sequence of an object and thereby completely describe its state.\nWe create a new object ins_A of class Protein. To this end, we call the class name like a function and supply the arguments required by the init method. Once the object ins_A has been created, we may access its attributes ([object name].[attribute name]).\nins_A = Protein(name=\"insulin A chain\", sequence=\"GIVEQCCTSICSLYQLENYCN\")\nprint(ins_A.name)\nprint(ins_A.sequence)\nprint(type(ins_A))\nThe built-in function type() tells us the class from which ins_A has been derived.\n\n\n\n\n\n\nImportant\n\n\n\nYou may wonder what happened to the first parameter (self) of __init__(). Why did we only specify two arguments (which were obviously assigned to the parameters name und sequence) when we instantiated the insulin object? Each instance method must be defined with at least one parameter (commonly called self), which refers to the current instance. However, we must not pass an argument to this parameter when invoking the instance method – Python supplies the appropriate value “automatically”.\n\n\n\n\n\nLet’s add a method to our class. (Simply insert the definition of mutate() into your file simple_protein.py. Mind the correct indentation level!)\nclass Protein:\n    def __init__(self, name, sequence):\n        self.name = name\n        self.sequence = sequence\n\n    # only add the following lines to your file\n    def mutate(self, pos, residue):\n        self.sequence = self.sequence[:pos] + residue + self.sequence[pos+1:]\nThe method mutate() creates a point mutation by replacing the amino acid at position pos by residue.\nins_A = Protein(\"insulin A chain\", \"GIVEQCCTSICSLYQLENYCN\")\nprint(ins_A.sequence)\n\nins_A.mutate(2, \"W\")\nprint(ins_A.sequence)\nmutate() works as expected: It changed the third residue (i.e., valine with index 2) to tryptophane.\nIn the following sections, we will learn about classes that are available from the standard library."
  },
  {
    "objectID": "python3.html#regular-expressions",
    "href": "python3.html#regular-expressions",
    "title": "Python Unit 3",
    "section": "Regular expressions",
    "text": "Regular expressions\n\nIntroduction\nThe re module (from the standard library) implements classes and functions for handling regular expressions. As you might remember from the bash course, a regular expression (“regex”) is a string that defines a search pattern and thereby describes sets of other strings.\nThe re module is quite comprehensive. Here, we only present some of its functions; for further information, please consult the documentation and the article Regular Expression HOWTO.\nfindall() searches for all non-overlapping occurrences of a regular expression (first argument) in a string (second argument) and returns all matches as list.\nfrom re import findall\n\nfindall(r\".ython\", \"Python or rather Jython?\")\nIt is recommended to define the regular expression by using a raw string (i.e., a string that includes a r immediately left of the opening quote). Within a raw string, the backslash is not interpreted as escape character, but as an actual backslash. You will see below why this approach is advantageous.\n\n\nSyntax\nPython’s syntax for regular expressions is similar to the bash syntax:\n\nThe dot . denotes an arbitrary character (see example above).\nCharacter classes are assembled by surrounding a list of characters in brackets.\nfindall(r\"H[au]nd\", \"Hand Hund Hend\")\nYou may also specify a range of characters …\nfindall(r\"H[a-t]nne\", \"Hanne Henne Hunne\")  # characters a to t\n… or exclude certain characters.\nfindall(r\"H[^e]nne\", \"Hanne Henne Hunne\")   # all characters except e\nSeveral predefined character classes are available, such as \\d (all decimal numbers) and \\w (all alphanumeric characters, including the underscore). If you want to use these classes, raw strings are particularly useful:\nfindall(\"\\\\d\\\\w\", \"this is 1a\")  # many backslashes, right?\nfindall(r\"\\d\\w\", \"this is 1a\")   # better!\nQuantifiers following a character indicate how often this character may appear.\ntarget = \"bt bat baat baaat baaaat baaaaaaaaat\"\nfindall(r\"ba*t\", target)     # zero or more times\nfindall(r\"ba+t\", target)     # one or more times\nfindall(r\"ba?t\", target)     # zero or once\nfindall(r\"ba{3}t\", target)   # exactly three times\nfindall(r\"ba{2,}t\", target)  # at least two times\nfindall(r\"ba{,3}t\", target)  # up to three times\nfindall(r\"ba{2,4}t\", target) # two to four times\nAlternatives search for one of two different strings.\nfindall(r\"one|two\", \"one two three\")\nAnchors restrict matches to the start or end of a string:\nfindall(r\"^a..\", \"auf dem Haus\")  # anchor at the start\nfindall(r\"a..$\", \"auf dem Haus\")  # anchor at the end\nGroups are created by parentheses surrounding one or more characters. Groups may be modified by a quantifier and allow to extract parts of a match:\nfindall(r\"animal: (\\w+) (\\w+)\", \"animal: Mus musculus (mouse)\")\n\n\n\n\n\n\n\nExample\n\n\n\nIn the code below, we extract all codes that start with the character 2 from a string. The resulting list contains three elements, each of which is a tuple with two strings representing the first and second matched group, respectively. Of course, we can interate over the list of matches.\ncodes = \"1a3, 1b4, 2c5, 2d6, 2e7, 3f8, 3g9\"\ncodes_starting_with_two = re.findall(r\"(2.)(.)\", codes)\ncodes_starting_with_two\n#&gt; [('2c', '5'), ('2d', '6'), ('2e', '7')]\n\nfor code in codes_starting_with_two:\n    print(code[1])\n#&gt; 5\n#&gt; 6\n#&gt; 7\n\n\n\n\nPattern objects\nFunctions like findall() are useful for simple searches. For more complex cases, we prefer to create a pattern object from a regular expression and then use its methods.\nfrom re import compile\n\np = compile(r\"animal: (\\w+) (\\w+)\")\ntype(p)\nprint(p.pattern)  # attribute: regex used for searching\nprint(p.groups)   # attribute: number of groups\nThe pattern object has a method search() that searches for matches in a string and returns a match object upon success.\nm = p.search(\"animal: Mus musculus (mouse)\")\ntype(m)\nLet’s have a closer look at the match object:\nm.groups()  # tuple with found groups\nm[0]        # whole match\nm[1]        # first group\nm.span()    # start and end index of the whole match\nm.start(2)  # start index of the second group\nm.end(1)    # end index of the first group"
  },
  {
    "objectID": "python3.html#reading-and-writing-files",
    "href": "python3.html#reading-and-writing-files",
    "title": "Python Unit 3",
    "section": "Reading and writing files",
    "text": "Reading and writing files\n\nHow to read individual characters\nBy reading user input via input() or from command line arguments (sys.argv) and by displaying output on the console (print()), a program may interact with the user. However, as soon as a program has to read large datasets, it it will become infeasible to enter those data manually. Thus, Python is able to read files existing files and to create new files and write contents to them.\nPlease copy the file codon_table.csv from the folder /resources/python into the folder python3 in your home directory and have a look at its first five lines:\nAAA,Lys,K,Lysine\nAAC,Asn,N,Asparagine\nAAG,Lys,K,Lysine\nAAT,Asn,N,Asparagine\nACA,Thr,T,Threonine\nThis file apparently represents a codon table, where an amino acid is specified for each base triplet. We open the file by using the built-in function open(), which returns a file object:\nf = open(\"codon_table.csv\", \"r\")\nf\nThe second argument of open() sets the file access mode – here, we only want to read the file. Python treats an opened file as a data stream, i.e., a (one-dimensional) sequence of data (in our case, characters) that can be accessed randomly.\nPython may read from a file in the following manner: Immediately after a file has been opened, the current stream position points to the first character (index 0), as the method tell(), well, tells us:\nf.tell()\nWe read the first 30 characters via read() and store them in the variable s:\ns = f.read(30)\ns\nThese 30 characters comprise the first line and part of the second line. After the reading operation, the stream position lies at the 31st character (index 30):\nf.tell()\nWe may, for example, go back to index 15 and read ten characters, or jump forward to index 100 and read two characters:\nf.seek(15)\nf.read(10)\nf.tell()\n\nf.seek(100)\nf.read(2)\nf.tell()\n\n\nHow to read a file line by line\nIn many cases, we will not need random access to the file. Since text files generally are composed of lines, they are usually read line by line (method readline()):\nf.seek(0)\nl1 = f.readline()\nl1\n\nl2 = f.readline()\nl2\nf.tell()\nThe strings l1 and l2 now contain the first and second line of the file, respectively, including the end of line character \\n. The stream position points to the first character in the third line. Note: Unfortunately, the end of a line is marked by different characters depending on the operation system. While Linux uses \\n (line feed), Windows uses \\r\\n (carriage return plus line feed), and older versions of operating systems on Mac even used \\r. Thus, you may run into problems if you process a file that has been created in Windows on Linux.\nFortunately, we don’t have to repeatedly call readline() to eventually read all files from: A file object may be iterated line by line, which facilitates reading within a for loop:\nf.seek(0)\nfor line in f:\n  print(line)\nEven more simply, we may save all lines in a list via readlines():\nf.seek(0)\nall_lines = f.readlines()\nall_lines\nIf we don’t need a file any longer, we must close it:\nf.close()\n\n\nHow to write to a file\nIn order to be able to write to a file, we have to open it with the respective access mode:\nf = open(\"some_lines.txt\", \"w\")\nNow the method write() allows us to write strings to the file:\nf.write(\"First line\\n\")\nf.write(\"Second line\\n\")\nIf we wish to write a collection of strings (e.g., a list of strings), the method writelines() allows us to do so. Attention: Python will write the list elements one after each other to the file, without inserting a new line character. Thus, if the list elements represent individual lines, we have to add an explicit newline character to the list elements:\nlines = [\"three\\n\", \"four\\n\", \"five\\n\"]\nf.writelines(lines)\nOnce we are done, we have to close the file. This is especially important after we have written data to the file, since Python may postpone writing operations. close() ensures that any pending operations are finished.\nf.close()\nFinally, have a look at the created file (cat).\n\n\nContext objects\nContext objects make file access even simpler. Instead of opening, reading/writing, and closing, a with block is used:\nwith open(\"codon_table.csv\", \"r\") as f:\n    all_lines = f.readlines()\n\nfor line in all_lines:\n    print(line)\nCreate a context object by writing - keyword with - function that returns a context object (here: open()) - keyword as - name for the context object (here: f) - colon - indented statements (suite)\nWithin the suite, the context object is defined (in our example, the open file is available for reading). As soon as the control flow exits the suite, Python makes sure that the context object is deinitialized (in the case of files, any pending writing operations are executed, and the file is closed)."
  },
  {
    "objectID": "python3.html#exercises",
    "href": "python3.html#exercises",
    "title": "Python Unit 3",
    "section": "Exercises",
    "text": "Exercises\nStore all files that you generate for unit 3 in the folder python3 in your home directory.\n\nExercise 3.1 (3 P)\nYou have successfully solved this exercise as soon as you have worked through this unit. In particular, the folder python3 must contain the following files, which you have created in the course of this unit:\n\ncodon_table.csv\nsimple_protein.py\nsome_lines.txt\n\n\n\nExercise 3.2 (4 P)\nCreate a class Protein with the following properties:\n\nThe init method requires the arguments name, uniprot_id, and sequence, which are stored in attributes of the same name.\nThe method get_length returns the number of amino acids in the protein.\nThe method contains has one parameter peptide and returns True if the protein sequence contains the given peptide sequence.\nThe method get_mw returns the molecular weight of the protein. The method has an optional parameter disulfides that specifies the number of disulfide bridges.\n\nThe molecular weight of a protein is given by the following formula:\nsum of the masses of the amino acid residues\n+ mass of a water molecule\n- 2 * mass of hydrogen * number of disulfide bridges\nPlease use the following masses:\nAA_MASS = dict(\n    G=57.05132, A=71.0779, S=87.0773, P=97.11518, V=99.13106,\n    T=101.10388, C=103.1429, L=113.15764, I=113.15764, N=114.10264,\n    D=115.0874, Q=128.12922, K=128.17228, E=129.11398, M=131.19606,\n    H=137.13928, F=147.17386, R=156.18568, Y=163.17326, W=186.2099\n)\n\nWATER_MASS = 18.01528\nH_MASS = 1.00784\nStore the class in exercise_3_2.py.\nYou may check that your program works correctly by using the following exemplary calls:\ngalanin = Protein(\"Galanin\", \"P22466\", \"GWTLNSAGYLLGPHAVGNHRSFSDKNGLTS\")\nprint(type(galanin))\n#&gt; &lt;class '__main__.Protein'&gt;\n\nprint(galanin.get_length())\n#&gt; 30\n\nprint(galanin.contains(\"CGSHLV\"))\n#&gt; False\n\nprint(galanin.get_mw())\n#&gt; 3157.4102999999996\n\n\ninsulin_B = Protein(\"Insulin B chain\", \"P01308\", \"FVNQHLCGSHLVEALYLVCGERGFFYTPKT\")\nprint(insulin_B.get_length())\n#&gt; 30\n\nprint(insulin_B.contains(\"CGSHLV\"))\n#&gt; True\n\nprint(insulin_B.get_mw(disulfides=1))\n#&gt; 3427.9056799999994\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nYou may build upon the Protein class we defined above. The init method has to define three attributes.\nYou have also learned how to implement methods. Think about the number of parameters, required vs optional, and the return value – these decisions are the same as for function design.\nIn get_mw(), you likely will need a counter variable and have to access dict values.\n\n\n\n\n\n\nExercise 3.3 (3 P)\nImplement a function read_masses which reads a table of atomic weights.\n\nThe function has a single parameter, which receives the name of the file containing the table.\nA table in CSV format is provided (/resources/python/average_mass.csv), whose first five lines read\nH,1.008\nHe,4.0026\nLi,6.94\nBe,9.0122\nB,10.81\nEach line contains two records separated by a comma: The element symbol and the average atomic mass. Therefore, you may process each line with a regular expression containing two groups.\nThe function should return a dict, where element symbols and masses are the key-value pairs.\n\nStore the function in exercise_3_3.py.\nYou may check that your program works correctly by using the following exemplary calls:\nm = read_masses(\"average_mass.csv\")\nprint(m[\"N\"])\n#&gt; 14.007\n\nprint(m[\"S\"])\n#&gt; 32.06\n\nprint(2 * m[\"H\"] + m[\"O\"])\n#&gt; 18.015\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nYou will have to open the file and read its contents.\nThe regex for parsing each line will contain two groups that capture the element and weight, respectively.\nCombine your knowledge on counter variables and dicts.\n\n\n\n\n\n\nExercise 3.4 (3 P)\nImplement a function calculate_mass, which calculates the mass of a chemical compound. The function is called with a string that contains the molecular formula (e.g., \"C6 H12 O6\" or \"C Cl4\") and returns the mass as a float.\nHints:\n\nExtract individual element symbols and their counts via a regular expression containing two groups. The first group should match one uppercase letter followed by an optional lowercase letter. The second group should match any number of digits.\n\nPlease use the following masses:\nMASSES = dict(\n    H=1.008, He=4.0026, Li=6.94, Be=9.0122, B=10.81,\n    C=12.011, N=14.007, O=15.999, F=18.998, Ne=20.18,\n    Na=22.99, Mg=24.305, Al=26.982, Si=28.085, P=30.974,\n    S=32.06, Cl=35.45, Ar=39.948, K=39.098, Ca=40.078\n)\nStore the function in exercise_3_4.py.\nYou may check that your program works correctly by using the following exemplary calls:\nprint(calculate_mass(\"C6 H12 O6\"))\n#&gt; 180.156\n\nprint(calculate_mass(\"H2 O\"))\n#&gt; 18.015\n\nprint(calculate_mass(\"C34 H46 Cl N3 O10\"))\n#&gt; 692.203\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nFor designing the regex to extract individual elements and their counts, think about how they are written: Each element starts with one uppercase letter, followed by one optional lowercase letter. The count has an arbitrary number of digits (i.e., it may also be missing, which indicates a count of 1). You will have to open the file and read its contents.\nYou will have to iterate over findall() results."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bioinformatics Practicals I",
    "section": "",
    "text": "Modern Life Sciences rely on various computer programs to analyze large biological datasets. The next generation of biologists thus requires basic expertise with high-performance computing, software tools, and automated application of analyses.\nIn this practical, you will learn to interact with operating systems through commands in an HPC environment as well as basics of programming in a scripting language."
  },
  {
    "objectID": "python4.html",
    "href": "python4.html",
    "title": "Python Unit 4",
    "section": "",
    "text": "The n-dimensional array is the central data structure of NumPy. It may represent vectors (one dimension), matrices (two dimensions), and tensors (three and more dimensions). In addition, NumPy provides a tremendous number of functions and methods for manipulating arrays and performing calculations involving them. The implementation of NumPy is highly efficient, facilitating arrays that contain millions of elements.\nUsually, the NumPy module is imported into a namespace np:\nimport numpy as np\n\n\nThere are various ways to create an array:\n\nfrom other data structures (lists, dicts, …)\nvia a function (e.g., np.zeros())\nby reading data from a file\n\nsome_numbers = [1, 4, 2, 5, 7]\na = np.array(some_numbers)  # create array from list\na\n\nb = np.arange(24)\nb\n\nc = np.zeros((3, 5))  \nc\nnp.arange() takes the same parameters as the range() function. np.zeros() creates an array containing zeros. The tuple (3, 5), which is passed as argument to this function, specifies the shape of the array, i.e., the number of elements in each dimension (called axes in NumPy). Here, the array contains three rows and five columns.\nWe may query basic properties of the array via the following attribues:\nc.ndim   # number of axes (dimensions)\nc.size   # number of elements\nc.shape  # shape\nThe shape of an array may be changed. For instance, a vector may be converted into a matrix, as long as the number of elements remains constant. Thus, we may convert the vector b (24 elements) to a 6x4 matrix or a 3x8 matrix, but not to a 5x5 matrix:\nb.reshape((6, 4))   # ok\nb.reshape((3, -1))  # ok; -1 -&gt; automatically determine the required size\nb.reshape((5, 5))   # error\n\n\n\n\n\n\nImportant\n\n\n\nCalling an array method returns a new array – the original object remains unchanged.\nb2 = b.reshape((6, 4))\nb2  # new 6x4 array\nb   # old 24x1 array\n\n\n\n\n\nIndexing and slicing return single elements or parts of an array. Remember that Python uses zero-based indexing, and that values are optional for the slicing operator.\nd = np.arange(12).reshape((4, 3))\nd\n\nd[0, 0]  # element in the first row and first column\nd[2, 1]  # element in the third row and second column\n\nd[0]       # first row\nd[-1]      # last row\nd[1:, :2]  # from the second row (inclusive) to the third column (exclusive)\nd[:, 0]    # all rows, first column\nd[::2]     # every second row\n\n\n\nArrays facilitate vector arithmetics, e.g., element-wise addition and multiplication, as well as the scalar product:\nx = np.array([0, 1, 2, 10, 100])\ny = np.array([3, 8, 12, 5, 13])\n\nx + y\nx * y\nnp.dot(x, y)\nHere is a selection of methods for numeric arrays:\nx.min()   # minimum value\nx.max()   # maximum value\ny.sum()   # sum of all values\ny.prod()  # product of all values\ny.mean()  # mean of all values\nInterestingly, calculations may involve arrays of different shapes. For example, the scalar value \\(x = 10\\) can be multiplied by the vector \\(y = (4, 1, 7)\\) by using a technique called broadcasting. The smaller array is “broadcast” across the larger array so that they have compatible shapes.\nx = np.array(10)\ny = np.array([4, 1, 7])\nx * y  # x is extended to [10, 10, 10] before multiplication\nBroadcasting also works in higher dimensions:\nnp.array([(1, 2), (3, 4), (5, 6)]) + np.array([10, 100])\n\n\n\nNumPy provides several ways to store the contents of an array in a file. save() creates a binary file in NPY format, while savetxt() creates a human-readable text file.\np = np.arange(10, 32, 3).reshape((4, 2))\np\n\nnp.save(\"my_array.npy\", p)\nnp.savetxt(\"my_array.txt\", p)\nFor each of these file formats, there are also reading functions:\nnp.load(\"my_array.npy\")\nnp.loadtxt(\"my_array.txt\")"
  },
  {
    "objectID": "python4.html#numpy",
    "href": "python4.html#numpy",
    "title": "Python Unit 4",
    "section": "",
    "text": "The n-dimensional array is the central data structure of NumPy. It may represent vectors (one dimension), matrices (two dimensions), and tensors (three and more dimensions). In addition, NumPy provides a tremendous number of functions and methods for manipulating arrays and performing calculations involving them. The implementation of NumPy is highly efficient, facilitating arrays that contain millions of elements.\nUsually, the NumPy module is imported into a namespace np:\nimport numpy as np\n\n\nThere are various ways to create an array:\n\nfrom other data structures (lists, dicts, …)\nvia a function (e.g., np.zeros())\nby reading data from a file\n\nsome_numbers = [1, 4, 2, 5, 7]\na = np.array(some_numbers)  # create array from list\na\n\nb = np.arange(24)\nb\n\nc = np.zeros((3, 5))  \nc\nnp.arange() takes the same parameters as the range() function. np.zeros() creates an array containing zeros. The tuple (3, 5), which is passed as argument to this function, specifies the shape of the array, i.e., the number of elements in each dimension (called axes in NumPy). Here, the array contains three rows and five columns.\nWe may query basic properties of the array via the following attribues:\nc.ndim   # number of axes (dimensions)\nc.size   # number of elements\nc.shape  # shape\nThe shape of an array may be changed. For instance, a vector may be converted into a matrix, as long as the number of elements remains constant. Thus, we may convert the vector b (24 elements) to a 6x4 matrix or a 3x8 matrix, but not to a 5x5 matrix:\nb.reshape((6, 4))   # ok\nb.reshape((3, -1))  # ok; -1 -&gt; automatically determine the required size\nb.reshape((5, 5))   # error\n\n\n\n\n\n\nImportant\n\n\n\nCalling an array method returns a new array – the original object remains unchanged.\nb2 = b.reshape((6, 4))\nb2  # new 6x4 array\nb   # old 24x1 array\n\n\n\n\n\nIndexing and slicing return single elements or parts of an array. Remember that Python uses zero-based indexing, and that values are optional for the slicing operator.\nd = np.arange(12).reshape((4, 3))\nd\n\nd[0, 0]  # element in the first row and first column\nd[2, 1]  # element in the third row and second column\n\nd[0]       # first row\nd[-1]      # last row\nd[1:, :2]  # from the second row (inclusive) to the third column (exclusive)\nd[:, 0]    # all rows, first column\nd[::2]     # every second row\n\n\n\nArrays facilitate vector arithmetics, e.g., element-wise addition and multiplication, as well as the scalar product:\nx = np.array([0, 1, 2, 10, 100])\ny = np.array([3, 8, 12, 5, 13])\n\nx + y\nx * y\nnp.dot(x, y)\nHere is a selection of methods for numeric arrays:\nx.min()   # minimum value\nx.max()   # maximum value\ny.sum()   # sum of all values\ny.prod()  # product of all values\ny.mean()  # mean of all values\nInterestingly, calculations may involve arrays of different shapes. For example, the scalar value \\(x = 10\\) can be multiplied by the vector \\(y = (4, 1, 7)\\) by using a technique called broadcasting. The smaller array is “broadcast” across the larger array so that they have compatible shapes.\nx = np.array(10)\ny = np.array([4, 1, 7])\nx * y  # x is extended to [10, 10, 10] before multiplication\nBroadcasting also works in higher dimensions:\nnp.array([(1, 2), (3, 4), (5, 6)]) + np.array([10, 100])\n\n\n\nNumPy provides several ways to store the contents of an array in a file. save() creates a binary file in NPY format, while savetxt() creates a human-readable text file.\np = np.arange(10, 32, 3).reshape((4, 2))\np\n\nnp.save(\"my_array.npy\", p)\nnp.savetxt(\"my_array.txt\", p)\nFor each of these file formats, there are also reading functions:\nnp.load(\"my_array.npy\")\nnp.loadtxt(\"my_array.txt\")"
  },
  {
    "objectID": "python4.html#pandas",
    "href": "python4.html#pandas",
    "title": "Python Unit 4",
    "section": "Pandas",
    "text": "Pandas\n\nCreate a DataFrame\nPandas builds upon NumPy arrays and provides data structures for comprehensive data analyses: Series (a one-dimensional array with an index) and DataFrame (a two-dimensional tabular structure). Each row of a DataFrame represents an observation, while each of its columns describes a variable (property) of these observations.\nUsually, the Pandas module is imported into a namespace pd:\nimport pandas as pd\nPandas provides several possibilities to create a DataFrame object, e.g., from nested lists or dicts, whose keys become column names:\ndata_list = [[\"a\", 2, True],\n             [\"b\", 5, True],\n             [\"c\", 8, False]]\npd.DataFrame(data_list)\n\ndata_dict = dict(A=[\"a\", \"b\", \"c\"],\n                 B=[2, 5, 8],\n                 C=[True, True, False])\npd.DataFrame(data_dict)\nImportantly, a DataFrame may be created by reading a file containing tabular data, such as a file in CSV format. Copy the file amino_acids.csv from /resources/python into a subfolder python4 in your home directory and look at its first five lines:\ncode,abbreviation,name,chem1,chem2,chem3,abundance,pi\nA,Ala,alanine,nonpolar,methylene,aliphatic,8.84,6.0\nC,Cys,cysteine,polar,sulfur,aliphatic,1.24,5.0\nD,Asp,aspartic acid,negative,methylene,aliphatic,5.39,3.0\nE,Glu,glutamic acid,negative,methylene,aliphatic,6.24,3.2\nObviously, this file collects chemical properties of the proteinogenic amino acids. Thus, each line describes an amino acid (= observation); each column contains data on one property (= variable), e.g., single letter code or isoelectric point.\nRead the contents of this file via pd.read_csv():\ndf = pd.read_csv(\"amino_acids.csv\")\ndf\n\n\n\n\n\n\nImportant\n\n\n\nread_csv() has more than 50 optional parameters, which can adjust almost any aspect of the reading process. Thereby, it supports a plethora of CSV dialects that can be found in the wild, since the CSV format has never been standardized.\n\n\n\n\nDataFrame properties\nLet’s investigate the DataFrame we just created:\ndf.head()   # these methods work\ndf.tail()   # similar to the bash commands\n\ndf.index    # (row) index\ndf.columns  # column index (names)\ndf.values   # values of the elements – a NumPy array\n\ndf.size     # number of elements\ndf.shape    # number of rows and columns\nCalculate descriptive statistics for the numeric columns:\ndf.median()  # median\ndf.mean()    # mean\ndf.std()     # standard deviation\n\n\n\n\n\n\nImportant\n\n\n\nCalling a method of a DataFrame returns a new object; the original DataFrame remains unchanged.\n\n\n\n\nSelecting data\nPandas provides several ways to select parts of a DataFrame, such as:\n\nselect columns via indexing with a string\ndf[\"code\"]                 # selecting a single column returns a Series\ndf[[\"name\", \"abundance\"]]  # selecting several columns returns a DataFrame \nselect rows by slicing with integers\ndf[:4]   # rows with index 0 to 3\ndf[2:6]  # rows with index 2 to 5\nselect rows with Booleans\ndf[df[\"pi\"] &gt; 7]  # selects all rows with basic amino acids\nThe statement above consists of three parts:\n\nSelect column pi (isoelectric point).\ndf[\"pi\"]\nCheck each value in this column if it is greater than 7. (Note that the scalar value 7 is broadcast along the vector representing the column.)\ndf[\"pi\"] &gt; 7\nSelect those rows in df where comparison (2) is true.\n\nlabel-based indexing via the .loc attribute\ndf.loc[2, \"code\"]            # element in the third row and column \"code\"\ndf.loc[3:6, \"code\":\"chem1\"]  # elements in rows four to seven\n                             # and columns \"code\" to \"chem1\"\n\n\n\n\n\n\nWarning\n\n\n\nIn contrast to all other slicing operations we have encountered, slicing within .loc also includes the end element.\n\n\nposition-based indexing via the .iloc attribute\ndf.iloc[4]          # row with index 4\ndf.iloc[:, 4]       # column with index 4\ndf.iloc[10:13, :4]  # rows with index 10 to 12, columns with index 0 to 3\n\nWhenever we select a single column of a DataFrame, Python returns a Series object. This class also implements a range of methods, e.g.,\nabundance = df[\"abundance\"]  # a Series\nabundance.sum()              # sum of the values in the Series\n\npI = df[\"pi\"]  # another Series\npI.mean()      # mean of the values in the latter Series\n\n\nModifying data\nIn the previous section, we learned how to select parts of a DataFrame via the index. Thus, it may be useful to convert a column of the DataFrame to a new index, which is done via the set_index() method:\ndf = df.set_index(\"abbreviation\")\ndf\n\ndf.loc[\"Ala\"]  # select the column describing alanine\nBy contrast, the row index may be converted back to a column:\ndf = df.reset_index()\ndf\nA DataFrame can be sorted based on the values in a row index, column index, or column. Keyword arguments of the respective method allow to configure the sort.\ndf = df.set_index(\"abbreviation\")\ndf.sort_index()                        # sort by row index\ndf.sort_index(axis=1)                  # sort by column index, i.e.,\n                                       # order columns by their name\n\ndf.sort_values(\"abundance\")            # sort ascending by \"abundance\"\ndf.sort_values(\"pi\", ascending=False)  # sort descending by \"pi\"\nYou may add and remove columns:\ndf[\"new_col\"] = 3                # add a new column \"new_col\"\ndf                               # the scalar 3 is broadcast\n\ndf = df.drop(\"new_col\", axis=1)  # remove the column; axis=1 specifies\ndf                               # that we want to remove a column\n\n\nJoins\nPandas allows to combine several DataFrames by a so-called join. In order to explain how joins work, load the table with amino acid data:\ndf_left = pd.read_csv(\"amino_acids.csv\")\ndf_left\nAlso load a second CSV file (available in /resources/python):\ndf_right = pd.read_csv(\"amino_acids_chemdata.csv\")\ndf_right\nThis second table lacks information on several amino acids (such as glycine) and describes two additional compounds “X” and “Z”.\nA join is a binary operation and thus requires two operands, which are usually called “left table” and “right table”. In each table, one or several columns are denoted as keys that are compared for joining. In the examples below, column code represents the key.\nThe merge() method allows to perform the following join types:\n\nThe left join uses all observations (rows) of the left table and adds information from the right table if the latter contains an observation with matching values in the key columns.\ndf_left.merge(df_right, how=\"left\", on=\"code\")\nThe resulting DataFrame contains 20 rows (i.e., the same number as the left table) and 17 columns (i.e., seven more as the left table – those were added from the right table). The right table contained data, e.g., for key \"A\"; therefore, data in its columns flexibility, i_vdw etc. were added to these columns in the resulting DataFrame. By contrast, the right table did not contain data for key \"F\". Therefore, columns in the left table were filled with NaN for this key. (NaN means “not a number” and represents missing values in Pandas.)\nThe right join works similar to the left join, but the roles of the left and right table are swapped:\ndf_left.merge(df_right, how=\"right\", on=\"code\")\nThe inner join only retains observations whose key exists in both the left and right table:\ndf_left.merge(df_right, how=\"inner\", on=\"code\")\nThe outer join retains observations whose key exists in at least one table:\ndf_outer = df_left.merge(df_right, how=\"outer\", on=\"code\")\ndf_outer\n\n\n\nSaving tables\nThe method to_csv() saves the contents of a DataFrame into a CSV file:\ndf_outer.to_csv(\"joined.csv\")\nSimilar to the function for reading CSV files, to_csv() can be modified by many parameters."
  },
  {
    "objectID": "python4.html#exercises",
    "href": "python4.html#exercises",
    "title": "Python Unit 4",
    "section": "Exercises",
    "text": "Exercises\nStore all files that you generate for unit 4 in the folder python4 in your home directory.\n\nExercise 4.1 (3 P)\nYou have successfully solved this exercise as soon as you have worked through this unit. In particular, the folder python4 must contain the following files, which you have created in the course of this unit:\n\nmy_array.npy\nmy_array.txt\namino_acids.csv\namino_acids_chemdata.csv\njoined.csv\n\n\n\nExercise 4.2 (3 P)\nImplement a function is_normal that checks whether two columns of a matrix are orthogonal to each other.\n\nThe function should be called with three parameters:\n\nthe name of a file that contains a numeric matrix and can be read via np.loadtxt()\nindex of one column that should be checked\nindex of another column\n\nThe function returns a Boolean value.\nTwo vectors are orthogonal to each other if their scalar product is zero.\nBe careful when you check whether the calculated scalar product is zero. Generally, one should never compare two floats via the equality operator (==). Rather, use the function isclose() provided by the math module.\n\nStore the function in exercise_4_2.py.\nYou may check that your program works correctly by using the following exemplary calls (vectors.txt is available in /resources/python):\n# compares the vectors [1 0 0 0 0] and [0 0 1 0 0]\nprint(is_normal(\"vectors.txt\", 0, 2))  \n#&gt; True\n\n# compares the vectors [3 -2 7 0 1] and [0 0 1 0 0]\nprint(is_normal(\"vectors.txt\", 1, 2))\n#&gt; False\n\n# compares the vectors [5 0 -2 8 -1] and [3 -2 7 0 1]\nprint(is_normal(\"vectors.txt\", 4, 1))\n#&gt; True\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nSee above how to read an array from a file and slice it. Calculation of the dot product is also explained above.\n\n\n\n\n\n\nExercise 4.3 (4 P)\nImplement a function translate() that translates a DNA sequence into a protein sequence and calculates the isoelectric point of the latter.\nWhile there are many ways to implement such a function, please adhere to the following specifications:\n\nThe function has a single parameter, which receives the DNA sequence as string. You may assume that the length of the string is always divisible by three.\nWithin the function, first create a DataFrame with one column containing codons of the DNA sequence. There are several ways to split the sequence into codons, e.g., via a for loop or by using the wrap() function from the textwrap module.\nLoad the CSV files amino_acids.csv (in your python4 folder) and codon_table_small.csv (in /resources/python) as DataFrames.\nJoin the three DataFrames. Think about the type of joins, their order, and which columns should be used as keys.\nThe function must return two values:\n\na string containing the protein sequence (you will have to apply the string method join() to one of the columns of the join result)\na float giving the mean isoelectric point of the protein sequence (see above)\n\n\nStore the function in exercise_4_3.py.\nYou may check that your program works correctly by using the following exemplary calls:\nprint(translate(\"AGCCCTCCAGGACAGGCTGCATCAGAAGAGGCCATCAAGCAGATCACTGTCCTTCTGCCA\"))\n#&gt; ('SPPGQAASEEAIKQITVLLP', 5.869999999999999)\n\nprint(translate(\"TGCGCCTCCTGCCCCTGCTGGCGCTGCTGGCCCTCTGGGGACCTGACC\"))\n#&gt; ('CASCPCWRCWPSGDLT', 5.824999999999999)\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nSee above how to create a DataFrame from a dict or from a CSV file, and how joins works. Also remember how to write a function that returns two values.\n\n\n\n\n\n\nExercise 4.4 (3 P)\nYou have used an online database to collect several properties of amino acids and downloaded the results as CSV file (/resources/python/data_ugly.csv). Alas, when you have a closer look at the CSV file, you note that it looks somewhat strange (only the first ten rows are shown below):\n# column 1: single-letter code\n# column 2: name\n# column 3: is the amino acid charged?\n# column 4: isoelectric point\n# column 5: for debugging\nA;alanine;nope;6_0;-1\nC;cysteine;nope;5_0;-1\nD;aspartic acid;sure;3_0;-1\nE;glutamic acid;sure;3_2;-1\nF;phenylalanine;nope;5_5;-1\nYou identify several problems in this file:\n\nColumns are separated by semicolons (;).\nThere is no row with column names. Instead, the first five rows apparently contain comments that start with a hash sigh (#) and explain the contents of each column.\nThe third column describes whether an amino acid is charged or not. Although you expected this column to contain Boolean values, the database labeled charged amino acids with sure and uncharged amino acids with nope.\nThe fourth column contains the isoelectric point. For unknown reasons, however, the underscore (_) is used as decimal separator!\nThe fifth column contains useless information and thus should be omitted.\n\nFortunately, you remember that Pandas’ read_csv() function may be configured via optional parameters. Thus, you assume that this function may even be able to load this terrible CSV file. The loaded file should look as follows (only the top five rows are shown):\n   code           name  charged    pi\n0     A        alanine    False   6.0\n1     C       cysteine    False   5.0\n2     D  aspartic acid     True   3.0\n3     E  glutamic acid     True   3.2\n4     F  phenylalanine    False   5.5\nImplement a function load_data() that has a single parameter (the name of the input file) and returns the correctly formatted dataframe. In addition, your code should save the correctly formatted DataFrame to data_tidy.csv.\nStore your code in exercise_4_4.py.\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nConsult the Pandas documentation to learn which arguments you will need to specify."
  },
  {
    "objectID": "bash.html",
    "href": "bash.html",
    "title": "Bash",
    "section": "",
    "text": "The command ssh lets you connect to the cluster. Note: you will need VPN active to be able to connect.\nssh [username]@corso.came.sbg.ac.at\n# For example:\nssh nfortelny@corso.came.sbg.ac.at\nNext you will change your password. Make sure to remember this password which you will you throughout this course.\npasswd\nNow we are connected to the cluster. In the following we will explore this file system. Details will be explored in the next lecture of this course. For now, just execute the commands and see if you can make sense of the results.\nThe cluster has a file system like any computer. Currently you are in your home directory. The current “path” is shown by the following command:\npwd\nYou can list the content of your home directory using\nls\nls -l\n\n\n\n\n\n\nWarning\n\n\n\nDo not confuse the lowercase letter l (as used in ls -l) with the number 1 (“one”).\n\n\nYou can clear the terminal by typing\nclear\nNow, use the up- and down-arrows on your keyboard to look through the history of commands.\nNow create a directory:\nmkdir day1\nList content of the directory again:\nls\nls -l                   # This shows you the home directory (and the day1 folder that is within the home directory)\nls -l day1/     # This shows you the content of the day1 folder\n\n\n\n\n\n\nTip\n\n\n\nNote: “folder” and “directory” mean the same thing.\n\n\nWhat does mkdir do? Bring up the manual (press “q” to exit the manual).\nman mkdir\nNow create some files. There are many ways to create a file.\n# Create an empty file in directory \"day1\"\ntouch day1/this_file_is_empty.txt\n\n# Write the text \"abcdefgh\" in a file.\necho \"abcdefgh\"  &gt; day1/letters.txt\nList files again.\nls\nls -l\nls -l day1/\nTake a look at the file content.\nhead day1/*"
  },
  {
    "objectID": "bash.html#connecting-to-the-cluster-day-1",
    "href": "bash.html#connecting-to-the-cluster-day-1",
    "title": "Bash",
    "section": "",
    "text": "The command ssh lets you connect to the cluster. Note: you will need VPN active to be able to connect.\nssh [username]@corso.came.sbg.ac.at\n# For example:\nssh nfortelny@corso.came.sbg.ac.at\nNext you will change your password. Make sure to remember this password which you will you throughout this course.\npasswd\nNow we are connected to the cluster. In the following we will explore this file system. Details will be explored in the next lecture of this course. For now, just execute the commands and see if you can make sense of the results.\nThe cluster has a file system like any computer. Currently you are in your home directory. The current “path” is shown by the following command:\npwd\nYou can list the content of your home directory using\nls\nls -l\n\n\n\n\n\n\nWarning\n\n\n\nDo not confuse the lowercase letter l (as used in ls -l) with the number 1 (“one”).\n\n\nYou can clear the terminal by typing\nclear\nNow, use the up- and down-arrows on your keyboard to look through the history of commands.\nNow create a directory:\nmkdir day1\nList content of the directory again:\nls\nls -l                   # This shows you the home directory (and the day1 folder that is within the home directory)\nls -l day1/     # This shows you the content of the day1 folder\n\n\n\n\n\n\nTip\n\n\n\nNote: “folder” and “directory” mean the same thing.\n\n\nWhat does mkdir do? Bring up the manual (press “q” to exit the manual).\nman mkdir\nNow create some files. There are many ways to create a file.\n# Create an empty file in directory \"day1\"\ntouch day1/this_file_is_empty.txt\n\n# Write the text \"abcdefgh\" in a file.\necho \"abcdefgh\"  &gt; day1/letters.txt\nList files again.\nls\nls -l\nls -l day1/\nTake a look at the file content.\nhead day1/*"
  },
  {
    "objectID": "bash.html#files-and-file-systems-day-2",
    "href": "bash.html#files-and-file-systems-day-2",
    "title": "Bash",
    "section": "Files and file systems (Day 2)",
    "text": "Files and file systems (Day 2)\n\nNavigate the file system\nFirst, let’s clean up.\nclear\nGo to the home directory (absolute path).\ncd ~/\nls -l\npwd\n\n\n\n\n\n\nTip\n\n\n\nThe “tilde” sign ~ is very useful. For names of special symbols (to google them), see the list at the bottom of this page.\n\n\nGo to the folder with all home directories (absolute path).\ncd /home\nls -l\npwd\nGo back to your home directory (absolute path).\ncd ~/\nls -l\npwd\nGo into the directory created yesterday (relative path - from your home directory).\ncd day1/\nls -l\npwd\nGo back one level (relative path - from the day1 folder).\ncd ../\nls -l\npwd\nLet’s create another folder (relative path - from your home directory). What does the -p stand for?\npwd\nmkdir -p day2/documents/texts\npwd\nChange permissions in a file created in the above folder. We will use the chmod command (https://en.wikipedia.org/wiki/Chmod). This command uses three digits between 0 and 7 to set the permissions of (i) the user, (ii) the group, and (iii) everyone else. The digit defines the permission, as explained in the following table.\n\n\n\nx\nPermission\nrwx\nBinary\n\n\n\n\n7\nread, write and execute\nrwx\n111\n\n\n6\nread and write\nrw-\n110\n\n\n5\nread and execute\nr-x\n101\n\n\n4\nread only\nr--\n100\n\n\n3\nwrite and execute\n-wx\n011\n\n\n2\nwrite only\n-w-\n010\n\n\n1\nexecute only\n--x\n001\n\n\n0\nnone\n---\n000\n\n\n\nNow create a test file. Then we will change permissions with chmod and look at them with ls -l. Rund these lines one by one and understand the output.\n# Create the file\necho \"Hello!\" &gt; day2/greeting.txt\nls -l day2\n\n# Change permissions\nchmod 711 day2/greeting.txt\nls -l day2\n\nchmod 722 day2/greeting.txt\nls -l day2\n\nchmod 733 day2/greeting.txt\nls -l day2\n\nchmod 744 day2/greeting.txt\nls -l day2\n\nchmod 755 day2/greeting.txt\nls -l day2\n\nchmod 766 day2/greeting.txt\nls -l day2\n\nchmod 777 day2/greeting.txt\nls -l day2\n\nchmod 700 day2/greeting.txt\nls -l day2\n\nman chmod\n\nExercises\n\nCreate a new folder called secrets within in the folder ~/day2.\nEnable full access to this folder for the owner of the folder, read access for the group, and no access for others\n\n\n\n\nGetting files\nMake sure you are in your home directory.\npwd\ncd ~/\n# same as \"cd \" or \"cd ~\", since the default value\n# for the dir argument is HOME (see \"man cd\")\n\npwd\nObtain the list of gRNAs.\n# look at the man pages of the following commands – what is their purpose?\nman mv\nman cp\n\n# now try it\nmv /resources/bash/gRNAs.txt ~/  # this will not work\ncp /resources/bash/gRNAs.txt ~/  # this works\n\n# Why does mv not work? Look at file permissions:\nls -l /resources/bash/gRNAs.txt\nls -l ~/gRNAs.txt\nNow explore the copied file.\nhead gRNAs.txt\nhead -5 gRNAs.txt\ntail -5 gRNAs.txt\nless gRNAs.txt\nmore gRNAs.txt\n\n# Count the number of lines\nwc -l gRNAs.txt\n\n\n\n\n\n\nTip\n\n\n\nYou may be used to a workflow where you first copy a file (e.g., Ctrl+C), then go to the destination folder, and paste it there (e.g., Ctrl+V). By contrast, the copy command cp does both the copying and pasting.\n\n\n\nExercises\nCopy the file gRNAs.txt from your home directory into the folder day2. Then rename the copied file in this folder to gRNAs_exercise.txt.\n\n\n\nEditing in nano\nNow add a line at the end of the file gRNAs.txt that is located in your home directory, adding the gRNA sequence “ACTGACTG”. Use the nano editor for this purpose. To quit the nano-editor you need to press Ctrl+X. Then type y+Enter to save the changes. Nano commands are shown in the editor and can be found on the internet. A list is provided below.\nNano commands:\n\n\n\nCommand\nFunction\n\n\n\n\nctrl+r\nread/insert file\n\n\nctrl+o\nsave file\n\n\nctrl+x\nclose file\n\n\nalt+a\nstart selecting text\n\n\nctrl+k\ncut selection\n\n\nctrl+u\nuncut (paste) selection\n\n\nalt+/\ngo to end of the file\n\n\nctrl+a\ngo to start of the line\n\n\nctrl+e\ngo to end of the line\n\n\nctrl+c\nshow line number\n\n\nctrl+_\ngo to line number\n\n\nctrl+w\nfind matching word\n\n\nalt+w\nfind next match\n\n\nctrl+\\\nfind and replace\n\n\n\nnano gRNAs.txt\nNow use nano to modify the shell to make things prettier. To do so change the file .bash_profile. This file contains settings for each user (the naming is just by convention). It starts with a ., which for Linux means the file is hidden.\nnano ~/.bash_profile\n# This creates the file and also opens it in nano\nAdd the following lines to .bash_profile in nano, then exit the file and save it - see the commands above. Note: Depending on your system, it may be difficult to copy and paste text into nano. You can also use the text editor that comes with MobaXterm, where copy/pasting should work.\nif [ -x /usr/bin/dircolors ]; then\n    test -r ~/.dircolors && eval \"$(dircolors -b ~/.dircolors)\" || eval \"$(dircolors -b)\"\n    alias ls='ls --color=auto'\n    alias grep='grep --color=auto'\nfi\nThe changes we added to .bash_profile will come into effect next time you log in. To also activate them for your current login, you can source the file, executing the commands stored within.\nls -l *\nsource ~/.bash_profile\nls -l *\nAlso, notice the difference in ls commands to show hidden files (like .bash_profile).\nls -l\nls -al\nNote: If your grade sheet does not show that the content of .bash_profile is correct but it still works, then leave it. There may be a small difference in between your version and the expected one that does not impact the functionality.\n\n\nZipped files\nNow let’s download all human gene sequences from Ensembl. Download the file to your home directory.\nman wget\nwget http://ftp.ensembl.org/pub/release-103/fasta/homo_sapiens/cds/Homo_sapiens.GRCh38.cds.all.fa.gz\nIf the above fails, then you can also copy the file from the resources folder into you home directory.\ncp /resources/bash/Homo_sapiens.GRCh38.cds.all.fa.gz ~/\nTo make sure you have the entire file properly downloaded, compare the MD5 hash of the file. MD5 hash functions are a compact digital fingerprint of a file. The MD5 hash of the file should be b16d46bf09c3b8b7909624f1e6c414ce.\nmd5sum ~/Homo_sapiens.GRCh38.cds.all.fa.gz\nmd5sum /resources/bash/Homo_sapiens.GRCh38.cds.all.fa.gz\nUse the du command to determine the file size.\ndu Homo_sapiens.GRCh38.cds.all.fa.gz\n\n# the -h argument displays the file size in a human-readable format\ndu -h Homo_sapiens.GRCh38.cds.all.fa.gz\nHave a look at this file.\nhead Homo_sapiens.GRCh38.cds.all.fa.gz\nThis doesn’t look great. Remember to clean up your terminal.\nclear\nThe above file is zipped. Now unzip it.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz\n# This command will run through the entire file which is very long.\n# Press Ctrl+C to stop the command.\n\nman gunzip\n# -c --stdout --to-stdout\n#   Write output on standard output; keep original files unchanged.\n#   If there are several input files, the output consists of a sequence \n#   of independently compressed members. To obtain better compression,\n#   concatenate all input files before compressing them.\nAgain, remember to clean up your terminal.\nclear\nCan we use head on the unzipped output? Yes - this is done using a pipe.\n\n\nPipes\nLinux pipes enables you to pass the output of one command to another command.\n\n\n\nPipe command\nFunction\n\n\n\n\ncmd &lt; file\nuse file as input for command cmd\n\n\ncmd &gt; file\nwrite output to file\n\n\ncmd &gt;&gt; file\nappend output to file\n\n\ncmd 2&gt; stderr\nwrite error output to file\n\n\ncmd &&gt; file\nsend output and error to file\n\n\ncmd1 | cmd2\nsend output of cmd1 to cmd2\n\n\n\nLet’s have a look at the first few lines of this file.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head\nSome programs let you look at decompressed output, for example\nzless Homo_sapiens.GRCh38.cds.all.fa.gz\n\n# very similar to:\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | zless\nNow we can also count the number of lines in this file:\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | wc -l\n\nExercises\nPlace the following files into the folder ~/day2, using pipes:\n\nStore the number of lines of Homo_sapiens.GRCh38.cds.all.fa.gz into the file lineNumber.txt.\nWrite the first 15 lines of Homo_sapiens.GRCh38.cds.all.fa.gz into the file lines1.txt.\nWrite the 31th to 35th line of Homo_sapiens.GRCh38.cds.all.fa.gz into the file lines2.txt.\nStore the size of Homo_sapiens.GRCh38.cds.all.fa.gz in Megabytes into the file size.txt."
  },
  {
    "objectID": "bash.html#patterns-and-regular-expressions-day-3",
    "href": "bash.html#patterns-and-regular-expressions-day-3",
    "title": "Bash",
    "section": "Patterns and regular expressions (Day 3)",
    "text": "Patterns and regular expressions (Day 3)\n\nFile pattern matches\nCommands can be executed on multiple files at the same time using pattern matches (we have used this already above).\nls -l\nls -l *\nls -l day*\nwc -l *\nwc -l *.gz\n\n\n\n\n\n\n\nDescription\nPattern\n\n\n\n\nMatch zero or more characters\n*\n\n\nMatch any single character\n?\n\n\nMatch any of the characters in a set\n[...]\n\n\nMatch zero or one occurrences of the patterns (extglob)\n?(patterns)\n\n\nMatch zero or more occurrences of the patterns (extglob)\n*(patterns)\n\n\nMatch one or more occurrences of the patterns (extglob)\n+(patterns)\n\n\nMatch one occurrence of the patterns (extglob)\n@(patterns)\n\n\nMatch anything that doesn’t match one of the patterns (extglob)\n!(patterns)\n\n\n\n\n\nSimple regular expressions\nRegular expressions can be executed on file names but also content within files. Below is the example from the PDF presented during the lecture. Note: The file sample needs to be copied to your home directory from the directory /resources/bash.\ncat sample\ngrep ^a sample\ngrep -E p\\{2} sample\ngrep \"a\\+t\" sample\nsed \"s/a/XXX/g\" sample\n\n\n\nDescriptions\nSymbol\n\n\n\n\nreplaces any character\n.\n\n\nmatches start of string\n^\n\n\nmatches end of string\n$\n\n\nmatches up zero or more times the preceding character\n*\n\n\nRepresent special characters\n\\\n\n\nGroups regular expressions\n()\n\n\nMatches up exactly one character\n?\n\n\n\n\n\nChecking the nucleotides in the Ensembl fasta file\nNow let’s use regulare expressions to explore the fasta file. Have a look at the first few lines.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -50\nWe expect all DNA sequences to be made up of A, C, T, and Gs. Now, we will verify this. First, we will get all DNA-sequences from this file, excluding lines starting with a &gt; (in a FASTA files, these lines are the lines describing the sequence; see https://en.wikipedia.org/wiki/FASTA_format).\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \"&gt;\"\n\n# from \"man grep\":\n# -v Invert the sense of matching, to select non-matching lines.\nNext we will use tr to delete newline characters. This will place all sequences in one (very long) line.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \"&gt;\" | tr -d '\\n'\nNext we place every character on a different line.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \"&gt;\" | tr -d '\\n' | grep -o .\nFinally, we want to remove repetition, to only see the unique nucleotides. To do so, we have to first sort the lines and then make them unique.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \"&gt;\" | tr -d '\\n' | grep -o . | sort | uniq\n\n# what happens if we only make them unique?\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \"&gt;\" | tr -d '\\n' | grep -o . | head -20\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \"&gt;\" | tr -d '\\n' | grep -o . | head -20 | uniq\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \"&gt;\" | tr -d '\\n' | grep -o . | wc -l\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \"&gt;\" | tr -d '\\n' | grep -o . | uniq | wc -l\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | grep -v \"&gt;\" | tr -d '\\n' | grep -o . | sort | uniq | wc -l\n\nExercises\n\nCreate a folder day3 in your home directory.\nCount the number of A, C, T, and G of the DNA sequences of the first 1000 lines of file Homo_sapiens.GRCh38.cds.all.fa.gz.\nStore each number in a file called nt_A.txt, nt_C.txt,… in the folder day3.\n\n\n\n\nReformatting the Ensembl fasta file\nNext, we will reformat the fasta file, such that every entry is on one line and the DNA sequence is at the end of the line.\nRemind ourselves of how this file looks like:\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500\nIn the original format, the &gt; separates different entries and sequences are in the lines below the line with &gt;. First, we will remove newline characters that separate the sequences. To remove the newline characters, we will use the sed command.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | sed -zE 's/([ACTG])\\n([ACTG])/\\1\\2/g'\nLet breack this up:\n\ns/// tells sed to substitute.\ns///g tells sed to substitue globally - replacing each occurance of x.\ns/x/y/g means we substitute x by y.\n([ACTG]) matches any of the four letters A, C, T, and G. The brackets () tell the regex to store the match for later (see \\1 and \\2 below). If we want to use this storing we need to use sed -E.\n\\n matches the newline.\n\\1 is going to be replaced by the first match within the first brackets (). Therefore, here it will be replaced by the nucleotide before the new line.\n\\2 is going to be replaced by the second match within the second brackets (). Therefore, here it will be replaced by the nucleotide after the new line.\nSo ultimately the nulceotide before and after the newline are stored, and then they are written again but without the newline.\n\nNext, we will remove the newline character that separates the sequence from the line with the entry information, which starts with &gt;, and replace it with seq:.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | head -500 | sed -zE 's/([ACTG])\\n([ACTG])/\\1\\2/g' | sed -z 's/\\n[^&gt;]/ seq:/g'\nExplanation:\n\n[^&gt;] means to NOT match &gt;.\n\\n[^&gt;] replaces all newline characters that are NOT before a &gt;.\n\nWe developed the above approach on the first lines. Now run it an the full file. This may take a couple of minutes. The gzip command will compress the results. The &gt; will store it in a new file GRCh38_reformatted.gz. The reformatted file should end up in your home directory.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | sed -zE 's/([ACTG])\\n([ACTG])/\\1\\2/g' | sed -z 's/\\n[^&gt;]/ seq:/g' | gzip &gt; GRCh38_reformatted.gz\nExplore the generated file.\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | wc -l\ngunzip -c Homo_sapiens.GRCh38.cds.all.fa.gz | grep \"&gt;\" | wc -l\ngunzip -c GRCh38_reformatted.gz | wc -l\nzless GRCh38_reformatted.gz\n\n\nIdentifying gRNA matches\nNow, with the newly formatted file, we can easily identify genes in the database that match a specific gRNA.\ngunzip -c GRCh38_reformatted.gz | head -30\nWe check that all entries have gene symbols:\ngunzip -c GRCh38_reformatted.gz | grep \"gene_symbol\" | head -30 \ngunzip -c GRCh38_reformatted.gz | grep -v \"gene_symbol\" | head -30 \n\n# remember: grep -v means to *not* match\nNext we extract those sequences matching the guide “TTAAGACA”:\ngunzip -c GRCh38_reformatted.gz | grep \"seq:[ACTG]*TTAAGACA\" | head -30 \nNow we extract the gene symbols of these matches. First we match all text (.*) from the beginning of the line (^) before the text gene_symbol and delete it.\ngunzip -c GRCh38_reformatted.gz | grep \"seq:[ACTG]*TTAAGACA\" | sed 's/^.*gene_symbol://g' | head -30\nThen we also remove all text after the gene symbol, in this case the space and everything (.*) after that until the end of the line ($).\ngunzip -c GRCh38_reformatted.gz | grep \"seq:[ACTG]*TTAAGACA\" | sed 's/^.*gene_symbol://g' | sed 's/ .*$//g'  | head -30\nFinally, we get unique gene IDs.\ngunzip -c GRCh38_reformatted.gz | grep \"seq:[ACTG]*TTAAGACA\" | sed 's/^.*gene_symbol://g' | sed 's/ .*$//g'  | sort | uniq\n\nExercises\nCreate the following files in the folder day3:\n\nExtract all entries with sequences matching the guide “GCGGTTTC” in the file guideMatch_GCGGTTTC.txt.\nWrite the count of entries with sequences starting with “TGC” into the file count_TGC.txt.\nWrite the count of entries of gene “MMP2” into the file count_MMP2.txt. Note: Do not count genes MMP20, MMP21,…\nWrite the count of unique genes whose symbol starts with “RPL” into the file count_RPL.txt.\nWrite the count of all unique protein coding genes into the file count_protein_coding.txt."
  },
  {
    "objectID": "bash.html#loops-and-variables-day-4",
    "href": "bash.html#loops-and-variables-day-4",
    "title": "Bash",
    "section": "Loops and variables (Day 4)",
    "text": "Loops and variables (Day 4)\n\nVariables\nVariables can hold information which can be passed to different programs.\nx=\"test variable\"\necho $x\necho $x | sed 's/a//g'\nNow we will write the gRNAs to test and the regexp patterns into variables.\nguide=TTAAGACA\necho $guide\npattern=\"seq:[ACTG]*${guide}\"\necho $pattern\ngunzip -c GRCh38_reformatted.gz | grep $pattern | head -30\ngunzip -c GRCh38_reformatted.gz | grep $pattern | sed 's/^.*gene_symbol://g' | sed 's/ .*$//g' | head -30\n\n\nLoops\nWe will use while loops. They have the following syntax:\nwhile [condition] do [something] done\nDifferent types of loops exist (https://ryanstutorials.net/bash-scripting-tutorial/bash-loops.php), but those are not important for this course.\nThe following loop starts with x = 1. It then repeats printing “Welcome … times” and adding +1 to x, until x is greater than 5 (while x is lower or equal to 5 $x -le 5).\nx=1\nwhile [ $x -le 5 ]\ndo\n  echo \"Welcome $x times\"\n  x=$(( $x + 1 )) # syntax to add a number to x\ndone\nImportantly, the loop is ONE construct. Thus when entering while [ $x -le 5 ], the terminal expects additional information, in particular do [...] done. While waiting for additional input, the terminal will start lines with &gt;. Keep entering the do, etc in those lines. The final results will look like this:\n[user]@corso:~$ while [ $x -le 5 ]\n&gt; do\n&gt; echo \"Welcome $x times\"\n&gt; x=$(( $x + 1 ))\n&gt; done\nWelcome 1 times\nWelcome 2 times\nWelcome 3 times\nWelcome 4 times\nWelcome 5 times\nTry to make the above loop count to 10. Or from 10 to 5.\nHere are different ways to compare numbers. Assume variable a holds 10 and variable b holds 20 then:\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\n\n\n\n\n-eq\nChecks if the value of two operands are equal or not; if yes, then the condition becomes true.\n[ $a -eq $b ] is not true.\n\n\n-ne\nChecks if the value of two operands are equal or not; if values are not equal, then the condition becomes true.\n[ $a -ne $b ] is true.\n\n\n-gt\nChecks if the value of left operand is greater than the value of right operand; if yes, then the condition becomes true.\n[ $a -gt $b ] is not true.\n\n\n-lt\nChecks if the value of left operand is less than the value of right operand; if yes, then the condition becomes true.\n[ $a -lt $b ] is true.\n\n\n-ge\nChecks if the value of left operand is greater than or equal to the value of right operand; if yes, then the condition becomes true.\n[ $a -ge $b ] is not true.\n\n\n-le\nChecks if the value of left operand is less than or equal to the value of right operand; if yes, then the condition becomes true.\n[ $a -le $b ] is true.\n\n\n\nYou can also use nano to write the code above into a file (for example here: script.sh) and then use the following to execute it:\nbash script.sh\nWe can also loop through the content of a file.\nwhile read p; do\n  echo \"$p\"\ndone &lt; gRNAs.txt\n\nExercise\nNow we will combine the above variables and loopes to test all guides in file gRNAs.txt against all DNA sequences in GRCh38_reformatted.gz. To do so you need the following steps (also see the hints below!!!):\n\nUse the code above (under Variables) that matches guides against DNA sequences and extracts gene symbols for matched sequences.\nPlace this function into the loop that iterates through the file gRNAs.txt, using the while loop shown above that iterates through a file.\nStore all matches (not just the top 30 coming from head -30) of each guide into a file that is named results_${guide}.txt. Place all files into a new folder day4 - ideally already within the loop.\nDouble-check the results by hand (no points).\n\nHow many files did you just create?\nLook at one of the created files. Is the content what you would expect?\nWhen you run it with only one guide (without the loop) and compare to the results generated within the loop: Do you get the right genes for this guide? Do you get the correct number of genes for this guide?\n\n\nHint: To complete the exercise, you can use the following code to extract genes for one guide. Note: In the following code black, the guide needs to be defined first using guide=[...]. In this exercise, you don’t define the guide - it should be defined by the loop.\necho $guide\npattern=\"seq:[ACTG]*${guide}\"\necho $pattern\ngunzip -c GRCh38_reformatted.gz | grep $pattern | sed 's/^.*gene_symbol://g' | sed 's/ .*$//g' | sort | uniq\nPlace the above in the loop that iterates throught the gRNA file.\nwhile read guide; do\n  echo $guide\ndone &lt; gRNAs.txt\nRemember: you need to save the result of the last line (gunzip ... | uniq) to a file results_${guide}.txt.\n\n\n\nComparing files\nHave a look at the files we generated.\ncd ~/day4\nls results_*.txt\nls -l results_*.txt\nhead results_*.txt\nwc -l results_*.txt\nNow let’s compare results in a pairwise manner. The command comm will provide the gene symbols unique to one or the other file, plus the intersection of both.\ncd ~/day4\ncomm results_AAGTTGGC.txt results_GCCATACA.txt\ncomm -12 results_AAGTTGGC.txt results_GCCATACA.txt\nThe count of genes in the overlap (intersection) can be stored in a new variable. To store results of an expression in a new variable, place the expression into parenthesis x=$().\ncd ~/\nguide1=AAGTTGGC\nguide2=GCCATACA\noverlap=$(comm -12 day4/results_${guide1}.txt day4/results_${guide2}.txt | wc -l)\necho \"$guide1 $guide2 $overlap\"\n\nExercise\nNow we will compare each pair of guides to test the overlap of genes. Place the result in the folder day4:\n\nUse one loop (iterating through all guides) within a second loop (also iterating through all guides) to compare the overlap between all pairs of guides.\nUse the comm command as shown above to extract the overlap, counting the number of genes, and writing the result into a file named overlap_${guide1}_${guide2}.txt.\n“Manually” check results (no points):\n\nHow many files did you create? How many did you expect to create?\nLook at one of the created files. Is the content what you would expect?\nCompare individual examples (for example “AAGTTGGC” vs “GCCATACA”). Did you get the right overlap?"
  },
  {
    "objectID": "bash.html#names-of-special-symbols",
    "href": "bash.html#names-of-special-symbols",
    "title": "Bash",
    "section": "Names of special symbols",
    "text": "Names of special symbols\n\nThe ( is called a parenthesis\nThe [ is called a bracket or “squared bracket”\nThe { is called a brace “curly bracket”\nThe ~ is called “tilde”\nThe * is called the “asterisk”"
  },
  {
    "objectID": "bash.html#useful-links",
    "href": "bash.html#useful-links",
    "title": "Bash",
    "section": "Useful links",
    "text": "Useful links\nLinux for bioinformatics\n\nhttps://bioinformaticsworkbook.org/Appendix/Unix/unix-basics-1.html#gsc.tab=0\nhttps://bioinformaticsworkbook.org/Appendix/Unix/UnixCheatSheet.html#gsc.tab=0\nhttps://bioinformatics.uconn.edu/unix-basics/#\nhttps://decodebiology.github.io/bioinfotutorials/\nhttps://www.melbournebioinformatics.org.au/tutorials/tutorials/unix/unix/\n\nGeneral linux commands\n\nhttps://www.thegeekstuff.com/2010/11/50-linux-commands/\n\nRegular expressions:\n\nhttps://www.guru99.com/linux-regular-expressions.html"
  },
  {
    "objectID": "python1.html",
    "href": "python1.html",
    "title": "Python Unit 1",
    "section": "",
    "text": "To use Python, please connect to Corso via ssh; on this virtual machine, all required programs have been installed.\nExecute the following statements in Python’s interactive mode. Try to understand the result of each statement. If you encounter any difficulties, please do not hesitate to contact your course instructor.\n\n\nNumeric types represent numbers.\n42      # the integer number forty-two\n3.1415  # a decimal number (float) that approximates pi\nThe hash sign # starts a comment, so Python will ignore all remaining characters on the line. (Thus, you may omit all comments when you enter the following code snippets into the Python interpreter!).\nNumbers may be manipulated via arithmetic operators:\n1 + 2    # addition\n7 - 4    # subtraction\n5 * 6    # multiplication\n5 ** 2   # exponentiation (\"5 to the power of 2\")\n54 / 7   # division\n10 % 4   # modulo – returns remainder\nThe assignment operator assigns a name to a value:\na = 343\nb = 14\nNow, the name (also called variable) may be used instead of the value in any statement:\na\na + b\nVariable names may comprise an arbitrary number of letters, digits, and underscores. However, a name must not start with a digit, and certain keywords (e.g., if and for) are disallowed as names.\nx = 1            # ok\nfirst_value = 1  # ok\nnumber5 = 1      # ok\n2much = 1        # syntax error – name starts with a digit\nfor = 1          # syntax error – for is a keyword\nLet’s calculate the circumference and area of a circle with radius 5:\n# do the math\npi = 3.1415792\nradius = 5\ncircumference = 2 * radius * pi\narea = (radius ** 2) * pi\n\n# print results\ncircumference\narea\nWe added explicit parentheses around radius ** 2 to indicate that Python should first calculate the power and then the product. (Actually, we could have omitted these parentheses, since the precedence of exponentiation is higher than the one of multiplication.) However, parentheses are required if the default operator precedence should be changed.\n3 * 5 + 8  # equivalent to (3 * 5) + 8\n3 * (5 + 8)\n\n\n\n\n\n\nWarning\n\n\n\nWhen in doubt, always use parentheses to structure your calculations!\n\n\nMoreover, never distract from the actual order of calculations by using spaces like\n3  *  5+8  # might imply that 5 and 8 are added first\n\n\n\nThere are only two Boolean values: True and False. Boolean types typically arise when using comparison operators:\n3 &gt; 2    # greater than\n7 &lt; 4    # less than\n10 &gt;= 8  # greater than or equal\n2 &lt;= 2   # less than or equal\n5 == 5   # equality\n10 != 9  # inequality\nLogical operators connect Boolean values to obtain new Booleans.\n(2 &lt; 3) and (15 / 4 &gt; 1)  # conjunction, true if both operands are true\n(5 != 5) or (12 &gt;= 13)    # disjunction, true if at least one operand is true\nnot (5 &lt; 7)               # negation changes true to false and vice versa\n\n\n\nA string is a sequence of Unicode characters enclosed in single or double quotes.\nstr_a = \"a string\"\nstr_b = 'also a string'\nstr_c = \"a string with 'single' quotes\"\nYou may also use multiline strings, which must be enclosed in triple quotes.\n'''a\nmulti-\nline\nstring'''\nString concatenation is done via the + operator:\nstr_a + str_b\nSince strings are sequences of characters, you can access a single character within a string by indexing.\nenzyme = \"adenylyl cyclase\"\nenzyme[0]    # first character\nenzyme[3]    # fourth character\nenzyme[-2]   # second character counting from the end of the string\n\n\n\n\n\n\nWarning\n\n\n\nPython uses zero-based indexing, i.e., the first element has index 0.\n\n\nSlicing extracts a substring, i.e., several characters from a string:\nenzyme[2:8]  # substring from the character at index 2\n             # (i.e., the 3rd character from the left)\n             # to the character before (!) index 8\n             # (i.e., the 8th character from the left)\nWhen using the slicing syntax [start index : end index], the character at the start index is included, while the character at the end index is excluded (!).\nBoth start index and end index are optional:\nenzyme[:4]   # substring up to index 3 (remember: the character\n             # at the end index is NOT included!)\nenzyme[9:]   # substring starting at index 9\nenzyme[:]    # a copy of the whole string\nenzyme[-3:]  # substring starting at index 3 counting from the right\n\n\n\nPython also knows a None type, which explicitly denotes the “nothing”:\nnothing = None\nnothing\nThe is operator checks whether a variable is None (do not use a comparison operator in this case):\nnothing is None  # preferred\nnothing == None  # avoid"
  },
  {
    "objectID": "python1.html#data-types-and-operators",
    "href": "python1.html#data-types-and-operators",
    "title": "Python Unit 1",
    "section": "",
    "text": "To use Python, please connect to Corso via ssh; on this virtual machine, all required programs have been installed.\nExecute the following statements in Python’s interactive mode. Try to understand the result of each statement. If you encounter any difficulties, please do not hesitate to contact your course instructor.\n\n\nNumeric types represent numbers.\n42      # the integer number forty-two\n3.1415  # a decimal number (float) that approximates pi\nThe hash sign # starts a comment, so Python will ignore all remaining characters on the line. (Thus, you may omit all comments when you enter the following code snippets into the Python interpreter!).\nNumbers may be manipulated via arithmetic operators:\n1 + 2    # addition\n7 - 4    # subtraction\n5 * 6    # multiplication\n5 ** 2   # exponentiation (\"5 to the power of 2\")\n54 / 7   # division\n10 % 4   # modulo – returns remainder\nThe assignment operator assigns a name to a value:\na = 343\nb = 14\nNow, the name (also called variable) may be used instead of the value in any statement:\na\na + b\nVariable names may comprise an arbitrary number of letters, digits, and underscores. However, a name must not start with a digit, and certain keywords (e.g., if and for) are disallowed as names.\nx = 1            # ok\nfirst_value = 1  # ok\nnumber5 = 1      # ok\n2much = 1        # syntax error – name starts with a digit\nfor = 1          # syntax error – for is a keyword\nLet’s calculate the circumference and area of a circle with radius 5:\n# do the math\npi = 3.1415792\nradius = 5\ncircumference = 2 * radius * pi\narea = (radius ** 2) * pi\n\n# print results\ncircumference\narea\nWe added explicit parentheses around radius ** 2 to indicate that Python should first calculate the power and then the product. (Actually, we could have omitted these parentheses, since the precedence of exponentiation is higher than the one of multiplication.) However, parentheses are required if the default operator precedence should be changed.\n3 * 5 + 8  # equivalent to (3 * 5) + 8\n3 * (5 + 8)\n\n\n\n\n\n\nWarning\n\n\n\nWhen in doubt, always use parentheses to structure your calculations!\n\n\nMoreover, never distract from the actual order of calculations by using spaces like\n3  *  5+8  # might imply that 5 and 8 are added first\n\n\n\nThere are only two Boolean values: True and False. Boolean types typically arise when using comparison operators:\n3 &gt; 2    # greater than\n7 &lt; 4    # less than\n10 &gt;= 8  # greater than or equal\n2 &lt;= 2   # less than or equal\n5 == 5   # equality\n10 != 9  # inequality\nLogical operators connect Boolean values to obtain new Booleans.\n(2 &lt; 3) and (15 / 4 &gt; 1)  # conjunction, true if both operands are true\n(5 != 5) or (12 &gt;= 13)    # disjunction, true if at least one operand is true\nnot (5 &lt; 7)               # negation changes true to false and vice versa\n\n\n\nA string is a sequence of Unicode characters enclosed in single or double quotes.\nstr_a = \"a string\"\nstr_b = 'also a string'\nstr_c = \"a string with 'single' quotes\"\nYou may also use multiline strings, which must be enclosed in triple quotes.\n'''a\nmulti-\nline\nstring'''\nString concatenation is done via the + operator:\nstr_a + str_b\nSince strings are sequences of characters, you can access a single character within a string by indexing.\nenzyme = \"adenylyl cyclase\"\nenzyme[0]    # first character\nenzyme[3]    # fourth character\nenzyme[-2]   # second character counting from the end of the string\n\n\n\n\n\n\nWarning\n\n\n\nPython uses zero-based indexing, i.e., the first element has index 0.\n\n\nSlicing extracts a substring, i.e., several characters from a string:\nenzyme[2:8]  # substring from the character at index 2\n             # (i.e., the 3rd character from the left)\n             # to the character before (!) index 8\n             # (i.e., the 8th character from the left)\nWhen using the slicing syntax [start index : end index], the character at the start index is included, while the character at the end index is excluded (!).\nBoth start index and end index are optional:\nenzyme[:4]   # substring up to index 3 (remember: the character\n             # at the end index is NOT included!)\nenzyme[9:]   # substring starting at index 9\nenzyme[:]    # a copy of the whole string\nenzyme[-3:]  # substring starting at index 3 counting from the right\n\n\n\nPython also knows a None type, which explicitly denotes the “nothing”:\nnothing = None\nnothing\nThe is operator checks whether a variable is None (do not use a comparison operator in this case):\nnothing is None  # preferred\nnothing == None  # avoid"
  },
  {
    "objectID": "python1.html#input-and-output",
    "href": "python1.html#input-and-output",
    "title": "Python Unit 1",
    "section": "Input and output",
    "text": "Input and output\nUse the print() function to display output on the screen.\nprint(\"Hello world!\")\nprint(3 + 5)\nBy contrast, the input() function reads values supplied by the user:\nvalue = input(\"Please enter any value: \")\nvalue\nAfter calling input(), Python reads an arbitrary number of characters until the user presses Enter.\nNote that input() always reads a string. Thus, the following program will not work as expected:\nnumber = input(\"Please enter a number: \")\nprint(number + 10)  # a string cannot be added to an integer!\nIf we plan to use the entered value for calculations, we must convert it to a numeric type via int() or float():\nx = \"10\"    # x contains the string \"10\"\ny = int(x)  # convert the string \"10\" to an integer 10\ny * 2       # this works as expected\n\na = float(\"2.3\")  # a is now the float 2.3\na / 5.6           # this works as expected\nNote, however, that you can apparently “multiply” a string with an integer. In this case, Python returns a new string that contains the original string n times (where n is the value of the integer).\nx * 2     # what happens here?!\n\"abc\" * 3 # another example\n\n\n\n\n\n\nExample\n\n\n\nThe following program asks the user to enter two numbers and then calculates their product. Store these statements in the file product.py and execute this file with Python (python product.py)! (To do so: exit the python console by typing exit() or the key combination Ctrl-D (Ctrl is Strg on a German keyboard), then open and edit the file in a text editor such as nano)\nprint(\"Calculate the product of two numbers\")\n\na = input(\"First number: \")\na = float(a)\n\nb = input(\"Second number: \")\nb = float(b)\n\nprint(\"The result is\", a * b)"
  },
  {
    "objectID": "python1.html#command-line-arguments",
    "href": "python1.html#command-line-arguments",
    "title": "Python Unit 1",
    "section": "Command line arguments",
    "text": "Command line arguments\nA Python program may also process values supplied on the command line (similar to a shell command). To enable this functionality, we have to import the sys module (unit 2 explains modules in more detail). We create a Python script arguments.py containing the following lines:\nfrom sys import argv\n\nprint(argv)\nprint(argv[0])\nprint(argv[1:])\nWe then execute the script as follows:\npython arguments.py a 12 third_argument\nThe program prints three lines that tell us:\n\nargv is a list with four elements. (The list type will be treated in unit 2. For now, you only need to know that you may access the elements of a list like characters in a string: Variable name followed by the index in brackets.)\nThe first element argv[0] contains the name of the script that was called ('arguments.py').\nThe remaining elements argv[1:] contain the command line arguments in the given order.\n\n\n\n\n\n\n\nExample\n\n\n\nBy using command line arguments, we may calculate the product of two numbers as shown below:\nfrom sys import argv\na = float(argv[1])\nb = float(argv[2])\nprint(\"The result is\", a * b)\nStore these statements in product2.py and execute the program:\npython product2.py 35 10"
  },
  {
    "objectID": "python1.html#exercises",
    "href": "python1.html#exercises",
    "title": "Python Unit 1",
    "section": "Exercises",
    "text": "Exercises\nEach unit concludes with several exercises which you should solve on your own. Your solutions will be graded, and the scores will be used to obtain your final grade for the course. The maximum number of points for the correct solution of each exercise is indicated.\nStore all files that you generate for unit 1 in the folder python1 in your home directory.\n\nExercise 1.1 (3 P)\nYou have successfully solved this exercise as soon as you have worked through this unit. In particular, the folder python1 must contain the following files, which you have created in the course of this unit:\n\nproduct.py\narguments.py\nproduct2.py\n\n\n\nExercise 1.2 (2 P)\nWrite a Python program that executes the following statements consecutively. Store the program in exercise_1_2.py.\n\nStore the integer 32 in the variable z and the float 2.5 in the variable a.\nStore the product of z and a in the variable b.\nDivide a by 8 and store the result in a.\nPrint whether a is greater than b (here, the program should print a single Boolean value.)\nPrint whether the sum of z and 11 is unequal to 44 (again, only print a single Boolean value).\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nSee section Data types and operators.\n\n\n\n\n\nExercise 1.3 (2 P)\nWrite a program exercise_1_3.py that prompts the user to enter three numbers and then displays whether the division of the first number by the second number yields a remainder that is equal to the third number.\nAn exemplary run of the program may yield the following output:\n$ python exercise_1_3.py\ndividend: 10\ndivisor: 4\nremainder: 2\nTrue\nThe user entered the three values 10, 4, and 2; subsequently, the program printed True.\nA different run of the program may look like\n$ python exercise_1_3.py\ndividend: 835\ndivisor: 111\nremainder: 20\nFalse\nIt does not matter whether your program prints anything in the input lines (such as “dividend:” above). However, it is important that the last printed line contains a single Boolean value that has been calculated correctly.\n\n\n\n\n\n\nTip\n\n\n\n\n\nSee this example.\n\n\n\n\n\nExercise 1.4 (3 P)\nWrite a program exercise_1_4.py that reads four command line arguments. (Below, these arguments are called dna, x, a, e.). The first argument is a string of arbitrary length which represents a DNA sequence. Arguments 2 to 4 are integers. The program should print two lines:\n\nThe first line contains the x-th base from the left in dna.\nThe second line contains the subsequence of dna that starts two bases before the position given by a and ends at the position given by e.\n\nBases are numbered starting from one (thus, the first base in the sequence is actually numbered “1”).\nYou may check that your program works correctly by using the following exemplary calls:\n                          x  a   e\n                          ↓  ↓   ↓\n$ python exercise_1_4.py AGCTATAGTAATCCAAT 2 5 9\nG\nCTATAGT\n\n                               a     x      e\n                               ↓     ↓      ↓\n$ python exercise_1_4.py ATCTACGCGATATCGCGATAGCCGATGCTGACGACTGACTTGACG 13 7 20\nT\nACGCGATATCGCGATA\n\n\n\n\n\n\nTip\n\n\n\n\n\nSee this example and the section on string indexing and slicing."
  },
  {
    "objectID": "python2.html",
    "href": "python2.html",
    "title": "Python Unit 2",
    "section": "",
    "text": "The Python interpreter executes the statements in a Python script one by one, and quits after the last statement.\na = 4\nb = 9\nc = 5\nmean = (a + b + c) / 3\nprint(mean)\nEvidently, this basic flow of control only allows you to write the most simple programs. Therefore, Python supports compound statements that alter the control flow.\n\n\n\n\n\n\nNote\n\n\n\nYou may run all of the following examples in interactive mode. However, if you are writing a compound statement, entering several indented lines may be tedious. Thus, you might prefer to create one Python script per example (such as func_test.py) and then run this script (e.g., python func_test.py).\n\n\n\n\nCall a function by writing\n\nfunction name\nleft parenthesis\narguments separated by commas\nright parenthesis\n\nWe already encountered print(), a so-called built-in function that prints its argument(s) to the standard output (stdout).\nprint(\"Hello world!\")\nDefine a function by writing\n\nkeyword def\nfunction name\nleft parenthesis\nparameters separated by commas\nright parenthesis\ncolon\nindented statements (suite)\n\nThe following function calculates the mean of three numbers:\ndef mean_of_three(a, b, c):\n    result = (a + b + c) / 3\n    return result\n\nm = mean_of_three(5, 8, 2)\nprint(m)\nA function may pass values to the caller by using the return statement. In the example above, Python assigns the return value to the variable m.\n\nA statement such as return value1, value2, value3 tells a function to return several values.\nA function that lacks a return statement implicitly returns None.\n\nIn order to correctly use functions, we need to understand the difference between parameters and arguments:\n\nA parameter (also called “formal parameter”) is part of the function definition and specifies the number (and sometimes also the type) of input values the function may receive.\nAn argument (also called “actual parameter”) is the value that is passed to a function when it is called.\n\nWhen defining a function, we need to distinguish between required and optional parameters:\n\nA required parameter must receive a value when the function is called.\nAn optional parameter may be omitted when the function is called. In this case, a default value that was specified in the function definition is assigned to the parameter.\n\nBelow, we define an exponential function. The parameter exponent is required; by contrast, base is optional, with a default value of 2.71828.\ndef exp(exponent, base=2.71828):\n    return base ** exponent\n\nprint(exp(4))  # equal to exp(4, 2.71828)\nprint(exp(4, 10))\nWhen calling a function, we need to distinguish between positional and keyword arguments:\n\nA positional argument is assigned to a parameter based on its position.\nA keyword argument is assigned to a parameter based on its key.\n\nprint(exp(4, 10))                # 4 -&gt; exponent, 10 -&gt; base\nprint(exp(base=10, exponent=4))  # 10 -&gt; base, 4 -&gt; exponent\n\n\n\nif statements will execute a block of code if and only if a condition is true:\nn = -1\n\nif n &lt; 0:\n    print(n, \"is negative\")\nCreate an if statement by writing\n\nkeyword if\ncondition (an expression that yields a Boolean value)\ncolon\nindented statements (suite)\n\nPython executes the code block following the if statement if the condition is true. If Python should also do something if the condition is false, you must add an else block:\nn = 5\n\nif n &lt; 0:\n    print(n, \"is negative\")\nelse:\n    print(n, \"is positive\")\nelif blocks allow you to chain if statements, i.e., to test an arbitrary number of conditions and execute a distinct set of statements for each condition. Thus, our final if statement, which also checks whether a provided number is zero, is:\nif n &lt; 0:\n    print(n, \"is negative\")\nelif n &gt; 0:\n    print(n, \"is positive\")\nelse:\n    print(n, \"is zero\")\n\n\n\n\n\n\nExample\n\n\n\nLet’s put the if statement which we developed above into a function. This will allow us to test several numbers for their sign. We will replace the print() statements with return, since our function should not print its result, but rather return it.\nThe function will format the result by means of an f-string (“formatted string literal”). An f-string is written as f\" ... \". It behaves like a normal string, but each part enclosed in curly braces {} is interpreted as Python statement whose result is inserted into the string.\nf\"An addition: {2+3}\"\n#&gt; 'An addition: 5' \nStore the following code in test_sign.py and execute the file with Python:\ndef test_sign(n):\n    if n &lt; 0:\n        return f\"{n} is negative\"\n    elif n &gt; 0:\n        return f\"{n} is positive\"\n    else:\n        return f\"{n} is zero\"\n\nprint(test_sign(102))\nprint(test_sign(-12))\nprint(test_sign(0))\n\n\n\n\n\n\n\nA while loop executes its suite as long as the given condition is true. Create such a loop by writing\n\nkeyword while\ncondition (an expression that yields a Boolean value)\ncolon\nindented statements (suite, loop body)\n\nStore the following code in calc_powers.py and execute the file with Python:\ni = 1\n\nwhile i &lt; 10000:\n    i = i * 2\n    print(i)\nTypically, the condition will become false after several iterations of the loop body. Above, the variable i receives a new value whenever the loop body is run.\n\n\n\nIn Python, a for loop is a so-called iterative loop, since it executes the same code block once for each value in a sequence and may access the current element within the loop body.\nCreate a for loop by writing\n\nkeyword for\nloop variable\nkeyword in\niterable object (e.g., string or list)\ncolon\nindented statements (suite, loop body)\n\nfor letter in \"Python\":\n    print(letter)\nThe loop above is executed six times, and during each run, the loop variable letter contains a different character of the string \"Python\" (i.e., the values \"P\", \"y\", \"t\", \"h\", \"o\", and \"n\").\n\n\n\n\n\n\nExample\n\n\n\nA common theme is to iterate over a list and store some information on each list element for later. Below, we initialize a counter variable with zero. We then iterate over a list of numbers and add each element to the counter variable. After the loop has finished, this variable therefore contains the sum of all numbers in the list.\ncounter = 0\n\nfor n in [1, 5, 13, 9, 4]:\n    counter = counter + n\n\nprint(counter)\n#&gt; 32\n\n\nSometimes we wish to iterate over a long sequence of numbers. It would be cumbersome if we had to explicitly write a list containing the numbers from, say, 0 to 10000 – there must be a simpler approach, right? Indeed, there is the built-in range() function, which generates a sequence of numbers.\nDepending on the numbers of arguments passed to range(), it will return\n\na sequence of integers from 0 to a final value (excluded)\nfor i in range(10):\n    print(i)\n#&gt; 0, 1, …, 9\na sequence of integers from an initial value (included) to a final value (excluded)\nfor i in range(2, 7):\n    print(i)\n#&gt; 2, 3, 4, 5, 6\na sequence of integers as above, using the third argument as step size:\nfor i in range(20, 3, -3):\n    print(i)\n#&gt; 20, 17, 14, 11, 8, 5\n\n\n\n\n\nModular programming is a technique that allows to split code into several files, each of which contains related functions and data types. Thereby, code may easily be reused, since a function\n\nhas to be implemented only once in a module (also called package)\nand then may be used by every program that imports this module.\n\nFor instance, the math module defines common mathematical functions. (math is part of the Python standard library, whose modules are available on each Python installation. Other modules must be installed by the user.)\nThe keyword import imports a module and creates a namespace with the same name, which allows us to call a function from the module as follows:\n\nnamespace\n.\nfunction name\n\nimport math\n\nmath.factorial(7)\nWe also may select a different name for the namespace upon importing:\nimport math as mathematics\n\nmathematics.factorial(7)\nMoreover, individual (or all) functions of a module may be imported into the global namespace:\nfrom math import factorial\n\nfactorial(7)\nTo increase readability of your code, you should place all import statements at the top of your Python script."
  },
  {
    "objectID": "python2.html#control-flow",
    "href": "python2.html#control-flow",
    "title": "Python Unit 2",
    "section": "",
    "text": "The Python interpreter executes the statements in a Python script one by one, and quits after the last statement.\na = 4\nb = 9\nc = 5\nmean = (a + b + c) / 3\nprint(mean)\nEvidently, this basic flow of control only allows you to write the most simple programs. Therefore, Python supports compound statements that alter the control flow.\n\n\n\n\n\n\nNote\n\n\n\nYou may run all of the following examples in interactive mode. However, if you are writing a compound statement, entering several indented lines may be tedious. Thus, you might prefer to create one Python script per example (such as func_test.py) and then run this script (e.g., python func_test.py).\n\n\n\n\nCall a function by writing\n\nfunction name\nleft parenthesis\narguments separated by commas\nright parenthesis\n\nWe already encountered print(), a so-called built-in function that prints its argument(s) to the standard output (stdout).\nprint(\"Hello world!\")\nDefine a function by writing\n\nkeyword def\nfunction name\nleft parenthesis\nparameters separated by commas\nright parenthesis\ncolon\nindented statements (suite)\n\nThe following function calculates the mean of three numbers:\ndef mean_of_three(a, b, c):\n    result = (a + b + c) / 3\n    return result\n\nm = mean_of_three(5, 8, 2)\nprint(m)\nA function may pass values to the caller by using the return statement. In the example above, Python assigns the return value to the variable m.\n\nA statement such as return value1, value2, value3 tells a function to return several values.\nA function that lacks a return statement implicitly returns None.\n\nIn order to correctly use functions, we need to understand the difference between parameters and arguments:\n\nA parameter (also called “formal parameter”) is part of the function definition and specifies the number (and sometimes also the type) of input values the function may receive.\nAn argument (also called “actual parameter”) is the value that is passed to a function when it is called.\n\nWhen defining a function, we need to distinguish between required and optional parameters:\n\nA required parameter must receive a value when the function is called.\nAn optional parameter may be omitted when the function is called. In this case, a default value that was specified in the function definition is assigned to the parameter.\n\nBelow, we define an exponential function. The parameter exponent is required; by contrast, base is optional, with a default value of 2.71828.\ndef exp(exponent, base=2.71828):\n    return base ** exponent\n\nprint(exp(4))  # equal to exp(4, 2.71828)\nprint(exp(4, 10))\nWhen calling a function, we need to distinguish between positional and keyword arguments:\n\nA positional argument is assigned to a parameter based on its position.\nA keyword argument is assigned to a parameter based on its key.\n\nprint(exp(4, 10))                # 4 -&gt; exponent, 10 -&gt; base\nprint(exp(base=10, exponent=4))  # 10 -&gt; base, 4 -&gt; exponent\n\n\n\nif statements will execute a block of code if and only if a condition is true:\nn = -1\n\nif n &lt; 0:\n    print(n, \"is negative\")\nCreate an if statement by writing\n\nkeyword if\ncondition (an expression that yields a Boolean value)\ncolon\nindented statements (suite)\n\nPython executes the code block following the if statement if the condition is true. If Python should also do something if the condition is false, you must add an else block:\nn = 5\n\nif n &lt; 0:\n    print(n, \"is negative\")\nelse:\n    print(n, \"is positive\")\nelif blocks allow you to chain if statements, i.e., to test an arbitrary number of conditions and execute a distinct set of statements for each condition. Thus, our final if statement, which also checks whether a provided number is zero, is:\nif n &lt; 0:\n    print(n, \"is negative\")\nelif n &gt; 0:\n    print(n, \"is positive\")\nelse:\n    print(n, \"is zero\")\n\n\n\n\n\n\nExample\n\n\n\nLet’s put the if statement which we developed above into a function. This will allow us to test several numbers for their sign. We will replace the print() statements with return, since our function should not print its result, but rather return it.\nThe function will format the result by means of an f-string (“formatted string literal”). An f-string is written as f\" ... \". It behaves like a normal string, but each part enclosed in curly braces {} is interpreted as Python statement whose result is inserted into the string.\nf\"An addition: {2+3}\"\n#&gt; 'An addition: 5' \nStore the following code in test_sign.py and execute the file with Python:\ndef test_sign(n):\n    if n &lt; 0:\n        return f\"{n} is negative\"\n    elif n &gt; 0:\n        return f\"{n} is positive\"\n    else:\n        return f\"{n} is zero\"\n\nprint(test_sign(102))\nprint(test_sign(-12))\nprint(test_sign(0))\n\n\n\n\n\n\n\nA while loop executes its suite as long as the given condition is true. Create such a loop by writing\n\nkeyword while\ncondition (an expression that yields a Boolean value)\ncolon\nindented statements (suite, loop body)\n\nStore the following code in calc_powers.py and execute the file with Python:\ni = 1\n\nwhile i &lt; 10000:\n    i = i * 2\n    print(i)\nTypically, the condition will become false after several iterations of the loop body. Above, the variable i receives a new value whenever the loop body is run.\n\n\n\nIn Python, a for loop is a so-called iterative loop, since it executes the same code block once for each value in a sequence and may access the current element within the loop body.\nCreate a for loop by writing\n\nkeyword for\nloop variable\nkeyword in\niterable object (e.g., string or list)\ncolon\nindented statements (suite, loop body)\n\nfor letter in \"Python\":\n    print(letter)\nThe loop above is executed six times, and during each run, the loop variable letter contains a different character of the string \"Python\" (i.e., the values \"P\", \"y\", \"t\", \"h\", \"o\", and \"n\").\n\n\n\n\n\n\nExample\n\n\n\nA common theme is to iterate over a list and store some information on each list element for later. Below, we initialize a counter variable with zero. We then iterate over a list of numbers and add each element to the counter variable. After the loop has finished, this variable therefore contains the sum of all numbers in the list.\ncounter = 0\n\nfor n in [1, 5, 13, 9, 4]:\n    counter = counter + n\n\nprint(counter)\n#&gt; 32\n\n\nSometimes we wish to iterate over a long sequence of numbers. It would be cumbersome if we had to explicitly write a list containing the numbers from, say, 0 to 10000 – there must be a simpler approach, right? Indeed, there is the built-in range() function, which generates a sequence of numbers.\nDepending on the numbers of arguments passed to range(), it will return\n\na sequence of integers from 0 to a final value (excluded)\nfor i in range(10):\n    print(i)\n#&gt; 0, 1, …, 9\na sequence of integers from an initial value (included) to a final value (excluded)\nfor i in range(2, 7):\n    print(i)\n#&gt; 2, 3, 4, 5, 6\na sequence of integers as above, using the third argument as step size:\nfor i in range(20, 3, -3):\n    print(i)\n#&gt; 20, 17, 14, 11, 8, 5\n\n\n\n\n\nModular programming is a technique that allows to split code into several files, each of which contains related functions and data types. Thereby, code may easily be reused, since a function\n\nhas to be implemented only once in a module (also called package)\nand then may be used by every program that imports this module.\n\nFor instance, the math module defines common mathematical functions. (math is part of the Python standard library, whose modules are available on each Python installation. Other modules must be installed by the user.)\nThe keyword import imports a module and creates a namespace with the same name, which allows us to call a function from the module as follows:\n\nnamespace\n.\nfunction name\n\nimport math\n\nmath.factorial(7)\nWe also may select a different name for the namespace upon importing:\nimport math as mathematics\n\nmathematics.factorial(7)\nMoreover, individual (or all) functions of a module may be imported into the global namespace:\nfrom math import factorial\n\nfactorial(7)\nTo increase readability of your code, you should place all import statements at the top of your Python script."
  },
  {
    "objectID": "python2.html#data-structures",
    "href": "python2.html#data-structures",
    "title": "Python Unit 2",
    "section": "Data structures",
    "text": "Data structures\n\nLists\nLists belong to the class of compound data types, which serve as a “collection” of other data types. Lists are created by enclosing comma-separated elements in brackets. For instance, the following list comprises the first eight prime numbers:\nprimes = [2, 3, 5, 7, 11, 13, 17, 19]\nprimes\nIndexing and slicing work as explained for strings, returning a single element or a new list containing the sliced elements, respectively:\nprimes[3]\nprimes[2:5]\nSince lists are mutable, you may change their elements:\nprimes[3] = 100\nprimes\nThe built-in function len() returns the number of elements in a list:\nlen(primes)\nImportantly, you may iterate over a list via a for loop:\nfor p in primes:\n    print(p)\nThe elements of a list may be lists themselves, which yields nested lists:\nnested_list = [\n    [1, 2, 3],\n    [4, 5],\n    [6, 7, 8, 9]\n]\nnested_list\nIndexing and slicing also work for nested lists:\nnested_list[2]\nnested_list[2][1]\nnested_list[2][1:3]\nSince lists are objects, they may be manipulated by special functions called methods. Methods are called like functions, but refer to a given object. Thus, the syntax for calling a method is as follows:\n\nname of the object\n.\nname of the method\nleft parenthesis etc. (like a function call)\n\nHere are some of the methods supported by lists (check the contents of bases after every statement!):\nbases = [\"A\", \"G\", \"X\", \"Y\"]\nbases.append(\"Z\")         # append an element to the list\ndel bases[2]              # delete element with index 2\nl = bases.pop()           # remove the last element and return it\nbases.extend([\"T\", \"U\"])  # appends elements from another list\nbases.insert(1, \"C\")      # insert the element given by the second argument\n                          # at the index given by the first argument\nbases.reverse()           # reverse order of elements\nbases.clear()             # delete all elements\n\n\nTuples\nTuples are similar to lists, since they also represent a sequence of items. In contrast to lists, however, tuples are immutable – once you have created a tuple, you can’t change it. Tuples support common list operations:\nbases = (\"A\", \"C\", \"C\", \"G\", \"T\")\n\"A\" in bases      # check whether the tuple contains an element\nbases[1:3]        # slicing\nlen(bases)        # number of elements\nmin(bases)        # smallest element\nmax(bases)        # largest element\nbases.count(\"C\")  # count the number of a given element\nbases.index(\"G\")  # find the index of a given element\n\n\nSets\nThe set is a sequential data type that represents a mathematical set – thus, sets are unordered. Both mutable and immutable variants are available (set and frozenset, respectively). We create a set by placing their elements between curly braces, or by converting from another sequential type:\nA = {2, 4, 5}        # variant 1: direct\nA1 = set([2, 4, 5])  # variant 2: converting a list\n\nA == A1              # are these sets equivalent?\nBesides adding and removing elements, you may also perform the classical set operations:\nB = {1, 2, 3, 4, 5}\nB.discard(5)  # remove element if it exists\nB.add(7)      # add element\nB.add(7)      # set does not change – each element must be unique!\n\nA | B  # union (OR)\nA & B  # intersection (AND)\nA - B  # difference\nB - A  # note that the difference is not commutative\nA ^ B  # symmetric difference (XOR)\n\n\nDictionaries\nDictionaries (“dicts”) are unordered collections of key-value pairs, where keys have to be unique. Create a dict\n\neither by separating key-value pairs by colons and enclosing comma-separated pairs with curly braces,\natom_names = {\"C\": \"carbon\", \"H\": \"hydrogen\", \"N\": \"nitrogen\"}\natom_names\nor by using the built-in function dict(), to which we supply the key-value-pairs as keyword arguments:\natom_names_2 = dict(C=\"carbon\", H=\"hydrogen\", N=\"nitrogen\")\natom_names_2\natom_names_2 == atom_names\n\nTypical dict operations include inserting, deleting, and – most importantly – searching:\natom_names[\"C\"]             # find the value associated with key \"S\"\natom_names[\"O\"] = \"oxygen\"  # insert a new key-value pair\ndel atom_names[\"H\"]         # delete the value associated with \"H\"\nYou may iterate over all key-value pairs in a dict via the .items() method and a for loop:\nfor key, value in atom_names.items():\n    print(key, value)"
  },
  {
    "objectID": "python2.html#exercises",
    "href": "python2.html#exercises",
    "title": "Python Unit 2",
    "section": "Exercises",
    "text": "Exercises\nStore all files that you generate for unit 2 in the folder python2 in your home directory.\n\nExercise 2.1 (3 P)\nYou have successfully solved this exercise as soon as you have worked through this unit. In particular, the folder python2 must contain the following files, which you have created in the course of this unit:\n\ntest_sign.py\ncalc_powers.py\n\n\n\nExercise 2.2 (3 P)\nImplement a function get_charge that checks whether an amino acid is positively charged (e.g., arginine), negatively charged (e.g., aspartate), or neutral (e.g., valine).\n\nThe function should be called with a single argument that specifies the amino acid using its single-letter abbreviation. Only the 21 eukaryotic proteinogenic amino acids should be considered.\nDepending on the charge, the function should return one of the strings \"positive\", \"negative\", or \"neutral\".\nIf the user does not supply a valid abbreviation, the function should return \"invalid input\".\n\nStore the function in exercise_2_2.py.\nYou may check that your program works correctly by using the following exemplary calls:\nprint(get_charge(\"D\"))\n#&gt; \"negative\"\n\nprint(get_charge(\"F\"))\n#&gt; \"neutral\"\n\nprint(get_charge(\"H\"))\n#&gt; \"positive\"\n\nprint(get_charge(\"foo\"))\n#&gt; \"invalid input\"\n\n\n\n\n\n\nTip\n\n\n\n\n\nYou have learned how to put an if statement into a function. In the section on tuples, you checked whether a tuple contained a given element. A similar test will be required for the if statement in this exercise.\n\n\n\n\n\nExercise 2.3 (3 P)\nImplement a function get_average_gc that calculates the average GC-content of several DNA or RNA sequences.\n\nThe function should be called with a single argument. It will receive a list containing an arbitrary number of strings, each of which represents a nucleotide sequence.\nThe function should return a single number, i.e., the average GC-content across all sequences.\n\nStore the function in exercise_2_3.py.\nYou may check that your program works correctly by using the following exemplary calls:\nprint(get_average_gc([\"CGACCACATTAATGGACTAC\", \"CTTGGATTATCACCCCCGTC\"]))\n#&gt; 0.5\n\nprint(get_average_gc([\"CCACCGAGACGCCAG\", \"CGGCCTCCCGAC\", \"GCCCGGGCCCGCGGGGGT\"]))\n#&gt; 0.837037037037037\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nUse a for loop to iterate over the strings in the list.\nYou will need a counter variable.\ns.count(\"X\") counts the number of times the character \"X\" appears in the string stored in s.\nThe len() function also works on strings.\n\n\n\n\n\n\nExercise 2.4 (3 P)\nIf you code a lot, you will often use third-party packages and consult their documentation. This is what we will do in this exercise: Implement a function make_sequence that creates a random DNA or RNA sequence of a given length and calculates how often a given base appears in this sequence.\n\nThe first (required) parameter sets the sequence length.\nThe second (optional) parameter rna decides whether an RNA or DNA sequence should be created. This parameter has a Boolean type and is false by default.\nThe third (optional) parameter count_base names the base that should be counted (default: \"A\").\nThe function should return two values: (1) A string representing the created sequence, and (2) how often the specified base appears.\n\nSince the function should create the sequence randomly, you might consider to use the function choices() available in the random module. This module is part of the standard library – please read the documentation. You will also need the string method join() to convert the value returned by choices() into a string. Since string is a built-in data type, it is also documented in the standard library.\nStore the function in exercise_2_4.py.\nYou may check that your program works correctly by using the following exemplary calls:\nrandom.seed(42)\nprint(make_sequence(20, False, \"A\"))\n#&gt; ('GACAGGTACAAGAAGGAGTA', 9)\n\nprint(make_sequence(15, rna=True, count_base=\"C\"))\n#&gt; ('UGCAUCAAUGUGGUC', 3)\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nExactly follow the specification of function parameters and return values:\n\nShould a parameter have a certain name?\nIf a parameter is optional, what is its default value?\nHow many values should the function return?\n\nSee the functions section for details.\nRemember how to import a function from a module.\n\n\n\n\n\n\nExercise 2.5 (3 P)\nIn this exercise, you will create a command line program that calculates the similarity of two tissue samples by means of their expressed genes.\n\nThe program should process two command line arguments genes1 and genes2.\nEach argument specifices the genes that are expressed in the respective sample. Individual genes should be separated by semicolons (e.g., GENE1;GENE2;GENE3;GENE4). It does not matter whether a gene appears more than once.\nThe program should print three values, each on a separate line:\n\nthe number of (unique) genes detected in the first sample\nthe number of (unique) genes detected in the second sample\nthe similarity of the samples, which is measured by the Jaccard index.\n\n\nYou may check that your program works correctly by using the following exemplary calls:\n$ python exercise_2_5.py \"RAB5C;PITX2;ZNF222;LMTK2;LMTK2\" \"RAB5C;PABPC4;ZNF222;PKN1;PTMA\"\n4\n5\n0.2857142857142857\n\n$ python exercise_2_5.py \"THOC5;RAD23B;GPR31;PIRC85;PANO1\" \"THOC5;ATP1A2;GPR31;THOC5\"\n5\n3\n0.3333333333333333\n\n$ python exercise_2_5.py \"RAD23B\" \"RAD23B\"\n1\n1\n1.0\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nYour program has to process command line arguments.\nTo split each argument into individual genes, the string method split()may be useful – see documentation.\nConsult the sets section on set creation from lists and calculation of union and intersection."
  }
]